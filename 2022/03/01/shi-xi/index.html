<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Xiaoxin's blog | Xiaoxin's blog</title><meta name="author" content="Xiaoxin,xiaoxinvvzzz@sina.com"><meta name="copyright" content="Xiaoxin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="项目 当需要设置的样式很多时设置className而不是直接操作style。 三十所时频数据项目主要是研究所做了一个数据加密的一个项目，需要我们对这个数据进行一个显示，前端主要是使用了vue3+elementui+echarts实现的， 由于研究所不能联网，所以做的是一些本地开发，也不部署到云服务器上面去，这里主要是学习到了一些与django后台对接的方法不同于其他，要在其根目录下找到templa">
<meta property="og:type" content="article">
<meta property="og:title" content="Xiaoxin&#39;s blog">
<meta property="og:url" content="http://beihai-yu.github.io/2022/03/01/shi-xi/index.html">
<meta property="og:site_name" content="Xiaoxin&#39;s blog">
<meta property="og:description" content="项目 当需要设置的样式很多时设置className而不是直接操作style。 三十所时频数据项目主要是研究所做了一个数据加密的一个项目，需要我们对这个数据进行一个显示，前端主要是使用了vue3+elementui+echarts实现的， 由于研究所不能联网，所以做的是一些本地开发，也不部署到云服务器上面去，这里主要是学习到了一些与django后台对接的方法不同于其他，要在其根目录下找到templa">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xin--images.oss-cn-hongkong.aliyuncs.com/images/20210916222408.jpeg">
<meta property="article:published_time" content="2022-02-28T17:02:21.291Z">
<meta property="article:modified_time" content="2022-11-19T12:56:32.823Z">
<meta property="article:author" content="Xiaoxin">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xin--images.oss-cn-hongkong.aliyuncs.com/images/20210916222408.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://beihai-yu.github.io/2022/03/01/shi-xi/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/img/pwa/manifest.json"/><meta name="msapplication-TileColor" content="#fff"/><link rel="apple-touch-icon" sizes="180x180" href="/img/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/pwa/16.png"/><link rel="mask-icon" href="/img/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?a82b3e053b6bc9439eaf4231e417c839";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"W5G1WE34L0","apiKey":"c18025cce7127ec55d20a9b82b001a5a","indexName":"xin_search","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Xiaoxin","link":"链接: ","source":"来源: Xiaoxin's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Xiaoxin\'s blog',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-11-19 20:56:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/static-butterfly/dist/css/index.min.css"><style type="text/css">.app-refresh{position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease}.app-refresh-wrap{display:flex;color:#fff;height:100%;align-items:center;justify-content:center}.app-refresh-wrap a{color:#fff;text-decoration:underline;cursor:pointer}</style><meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Xiaoxin's blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://xin--images.oss-cn-hongkong.aliyuncs.com/images/20210803214122.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fas fa-play-circle"></i><span> 番剧</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-image"></i><span> 相册</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://xin--images.oss-cn-hongkong.aliyuncs.com/images/20210916222408.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Xiaoxin's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fas fa-play-circle"></i><span> 番剧</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-image"></i><span> 相册</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">无题<a class="post-edit-link" href="null_posts/实习.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-28T17:02:21.291Z" title="发表于 2022-03-01 01:02:21">2022-03-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-19T12:56:32.823Z" title="更新于 2022-11-19 20:56:32">2022-11-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">55k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>190分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2022/03/01/shi-xi/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2022/03/01/shi-xi/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="项目">项目</h2>
<p>当需要设置的样式很多时设置className而不是直接操作style。</p>
<p>三十所时频数据项目主要是研究所做了一个数据加密的一个项目，需要我们对这个数据进行一个显示，前端主要是使用了vue3+elementui+echarts实现的，</p>
<p>由于研究所不能联网，所以做的是一些本地开发，也不部署到云服务器上面去，这里主要是学习到了一些与django后台对接的方法不同于其他，要在其根目录下找到template文件夹放在里面，</p>
<p>做过一个有websocket的小demo</p>
<p>网络理政中心项目主要是对网络理政中心的大屏温度进行监控，房间里通过传感器对电流，电压进行显示，防止出现温度过高，电流过载。项目主要分为数据概览显示了当前监控的传感器具体情况，设备管理模块，对设备的基本信息做了表单呈现，数据监控模块可以温度历史数据，报警管理主要是对设备出现报警的具体内容进行呈现，用户管理是呈现当前用户的一些信息，其中如果是管理员的话可以对成员信息进行增删改，不是的就不行，最后是日志管理，可以看最新的日志，也可以查询某段时间的。最后是大屏实时数据的可视化模块，主要是对大屏数据进行一个热力图的实时的展示还有一些其他的信息。</p>
<p>技术主要是主要是采用了vue+elementui+echarts来做的，其中某些elementui没有的一些图标，比如一些传感器图标，报警图标。所以使用了阿里的图标库的图标，项目搭建完后部署在了nginx服务器上。</p>
<p>在项目部署过程中，因为要提前部署到甲方提供的服务器上，所以发现要对整个代码都需要进行加密，以前一直觉得前端代码在webpack打包以后应该算是加密状态，后来了解到有一些反编译的手段可以吧前端代码反编译出来，所以对加密这一块做了一些了解，刚开始的时候连接到UglifyJsPlugin对代码有代码压缩及混淆功能，可以对代码进行压缩，变量、函数名替换为简单字母，降低了源码的可读性，一定程度上达到了加密的目的，但我调整了一些参数后去对比了加密了的打包文件和没有加密的发现差别很小，所以查询了一些资料，发现可以使用 <code>webpack-obfuscator</code> 来给代码增加随机废代码段、字符编码转义等方法可以使构建代码完全混淆，实现无法恢复源码甚至无法阅读的目的。同时又发现这个插件对webpack3不支持了，于是又兜兜转转去吧webpack升级了一下，调整了一下打包参数才实现了这个功能。</p>
<p>还有一个复杂的地方在于在最初的设想的时候，想对这个热力图的每一块进行捕捉，然后返回这块屏幕的具体信息。这里调用了echarts的api作用相当于对图中某一块的点击做了一个监听得到有个params参数，对这个参数做处理得到我们具体点位坐标，由于查询得到的信息要呈现在另外一个页面里面，于是对这个点击生成的变量做了一个watch变量监听，然后调用具体函数，在通过这个函数把这个变量放到了vuex中。同时在这个呈现设备信息的页面做了一个对vuex中这个变量的watch监听，然后再通过ajax调用后端具体接口得到这个设备的信息</p>
<p>项目优化：做过页面的自适应使用的是淘宝的lib-flexible（根节点会根据页面视口变化而变化font-size大小。）和px2rem插件(我们通过配置基准，实现将px自动换算成rem，)，同时吧项目中所有的style设置成className。</p>
<p>在打包项目是，发现打包后终端会显示一些包文件过大，于是在stactic文件中定位到具体的文件，查看代码，发现是echarts是通过本地的包文件来使用的，然后改为了在index.html中cdn的资源引用方式。</p>
<h4 id="权限问题">权限问题</h4>
<h2 id="面试题">面试题</h2>
<p>《JavaScript 高级程序设计》《CSS 权威指南》</p>
<p>学习路径：学习HTML，然后学习了css，学习了js的基础，然后不想哄学习CSS，然后学习vue框架，ajax，elementuicss框架，echars，vuex，vue-router，一些插件的使用，websocket，webpack，nginx，nodejs，mysql，spring，</p>
<h3 id="一些对比">一些对比</h3>
<h4 id="说一下使用Jquery和使用vue的区别">说一下使用Jquery和使用vue的区别</h4>
<p><strong>Jquery</strong>是对<strong>繁琐的Dom操作进行了封装</strong>，同时也在里面封装了兼容浏览器的处理方式，更方便开发人员选取和操作DOM对象，在这里，<strong>视图和数据是耦合在一起的</strong>，这样不利于复杂业务逻辑的开发；</p>
<p>而vue解耦了视图和数据，将Dom相关操作完全封装在了内部，通过数据来驱动视图，它只关心数据的变化，将开发人员<strong>从繁琐复杂的Dom操作中解放了出来</strong>，能够更加专注于前端业务逻辑的实现。</p>
<h3 id="HTML">HTML</h3>
<h4 id="link和-impor区别">link和@impor区别</h4>
<pre class="language-none"><code class="language-none">1、link是html的标签，不仅可以加载css还可以定义Rss , rel连接属性；@import是css的语法规则，只能引入样式；
2、加载页面时，link是同时加载的，@impor是页面加载完后才加载
3、link没有兼容性的问题，而@import只在较高版本的浏览器才可以识别
4、link可以通过js插入操作dom，@import 不可以！</code></pre>
<h4 id="图片懒加载">图片懒加载</h4>
<pre class="language-none"><code class="language-none">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- 由于识别不了data-src属性，所以不知道去哪儿下载， --&gt;
    &lt;img data-src="1.gif"&gt;
    &lt;img data-src="2.gif"&gt;
    &lt;img data-src="3.gif"&gt;

    &lt;script&gt;
        const images = document.querySelector('img')
        const callback = entries =&gt;{
            entries.forEach(entry =&gt; {
                // isIntersecting表示是否进入到可视区域，true时代表此次触发回调函数时观察到了图片
                if(entry.isIntersecting) {
                    // target代表目标元素
                    const image = entry.target;
                    // 获取相应的图片属性
                    const data_src = image.getAttribute('data-src')
                    // 修改为可见的src属性
                    image.setAtrribute('src', data_src)
                    // 已经观察过了，取消observer观察动作
                    observe.unobserve(image)
                    console.log("触发")
                }
            });
        }

        const observe = new IntersectionObserver(callback);
        // 开始观察每一张图片
        images.forEach(image=&gt;{
            observe.observe(image);
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h3 id="css">css</h3>
<h4 id="水平垂直居中">水平垂直居中</h4>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- &lt;script&gt;
        // width - viewport的宽度 height - viewport的高度
        // initial-scale - 初始的缩放比例
        // minimum-scale - 允许用户缩放到的最小比例
        // maximum-scale - 允许用户缩放到的最大比例
        // user-scalable - 用户是否可以手动缩放
        // 实现0.5px的线
      &lt;meta name="viewport"content="initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/&gt;
    &lt;/script&gt; --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>parent<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>child<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
         我是内容我是内容我是内容我我是内容我是内容我是内容
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
<span class="token comment">/* text-align与line-hight*/</span>
<span class="token comment">/* .child{
    text-align:center;
    line-height:200px;
    width: 500px;
    height: 200px;
    background: #80ff80;
    font-size: 20px
} */</span>

<span class="token comment">/*父类中 display: flex;justify-content: center;align-items: center;*/</span>
<span class="token comment">/* .parent{
  height: 300px;
  border: 3px solid red;

  display: flex;
  justify-content: center;
  align-items: center;
}
.child{
  border: 3px solid green;
  width: 300px;
} */</span>

<span class="token comment">/*相对，绝对  top: 50%;left: 50%;transform: translate(-50%,-50%);  */</span>
<span class="token comment">/* .parent{
  height: 300px;
  border: 3px solid red;
  position: relative;
}
.child{
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%,-50%);
} */</span>

<span class="token comment">/*相对，绝对   margin: auto;top: 0;bottom: 0;left: 0;right: 0;  */</span>
<span class="token comment">/* .parent{
  height: 600px;
  border: 1px solid red;
  position: relative;
}
.child{
  width: 300px;
  height: 200px;
  border: 1px solid green;

  position: absolute;
  margin: auto;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
} */</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre>
<h5 id=""></h5>
<h4 id="三栏布局">三栏布局</h4>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Left<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Right<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Main<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span></code></pre>
<pre class="language-none"><code class="language-none">.left{
          background-color: #ffb;
          float: left;
          width: 200px;
      }
      .right{
          background-color: #f65;
          float: right;
          width: 200px;
      }
      .main{
          background-color: #ccc;
          overflow: hidden;
      }</code></pre>
<h4 id="PNG">PNG</h4>
<p>PNG8格式图片的颜色模式是：（索引）颜色，在修改前要先更改颜色模式为RGB颜色。</p>
<h4 id="font-12px-2">font:12px/2</h4>
<p>已知这样一段HTML:</p><p class="a"></p>,应用这样一段css： .a{font:12px/2 arial;},则这个p元素的line-height的值是(24)px.<br>
分析：font:12px/2 这是缩写形式，font-size为12px，line-height位font-size的2倍，24px。<p></p>
<h4 id="CSS选择器优先级">CSS选择器优先级</h4>
<blockquote>
<p>不同级别：！important（在样式属性后不加“;”，在!important后加分号）&gt;行内样式&gt;ID选择器&gt;Class选择器&gt;标签&gt;通配符</p>
</blockquote>
<h6 id="相同级别：">相同级别：</h6>
<blockquote>
<p>（1）同一级别中后写的会覆盖先写的样式<br>
（2）选择器约分</p>
</blockquote>
<p>**CSS优先级：是由四个级别和各级别出现次数决定的<br>
四个级别：行内样式，ID选择器，Class选择器，标签<br>
每个规则对应一个初始值0,0,0,0<br>
若是 行内选择符，则加1、0、0、0</p>
<p>若是 ID选择符，则加0、1、0、0</p>
<p>若是 类选择符/属性选择符/伪类选择符，则分别加0、0、1、0</p>
<p>若是 元素选择符/伪元素选择符，则分别加0、0、0、1</p>
<p>算法：将每条规则中，选择符对应的数相加后得到的”四位数“，从左到右进行比较，大的优先级越高。**</p>
<p><strong>注意：</strong><br>
①、!important的优先级是最高的，但出现冲突时则需比较”四位数“;</p>
<p>②、优先级相同时，则采用就近原则，选择最后出现的样式;</p>
<p>③、继承得来的属性，其优先级最低;</p>
<p>!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</p>
<p>css选择器使用强烈建议采用低权重原则，利于充分发挥css的继承性，复用性，模块化、组件化。</p>
<h4 id="盒子模型">盒子模型</h4>
<ul>
<li><strong>argin(外边距)</strong> - 清除边框外的区域，外边距是透明的。</li>
<li><strong>Border(边框)</strong> - 围绕在内边距和内容外的边框。</li>
<li><strong>Padding(内边距)</strong> - 清除内容周围的区域，内边距是透明的。</li>
<li><strong>Content(内容)</strong> - 盒子的内容，显示文本和图像。</li>
</ul>
<p>标准盒子模型的<strong>width 和 height 指的是内容区域</strong>的宽度和高度和IE盒子模型的，<strong>width 和 height 指的是内容区域+border+padding</strong>的宽度和高度。</p>
<p><strong>标准盒子模型和IE盒子模型(怪异盒子模型)</strong>，怪异盒子模型通过  box-sizing: border-box;来触发</p>
<p><img src="https://xin--images.oss-cn-hongkong.aliyuncs.com/images1/202202250923354.png" alt="image-20220225092327102"></p>
<p><img src="https://xin--images.oss-cn-hongkong.aliyuncs.com/images1/202202250923901.png" alt="image-20220225092332787"></p>
<p><strong>面试真题：</strong></p>
<p>4、已知这样一段HTML，</p><div class="a"><div class="b"></div></div>，如果应用了这样一段css，<p></p>
<p>.a{width:100px;padding:10px;box-sizing:border-box;}<br>
.b{width:100%;height:10px;background-color:red}<br>
1<br>
2<br>
那么红色区域的宽度为：B</p>
<p>A. 90px<br>
B. 80px<br>
C. 110px<br>
D. 100px</p>
<p>分析：box-sizing:border-box;是怪异盒模型，border、padding不会撑开盒子的大小。默认是content-box，标准盒模型,border、padding会撑开盒子的大小.所以b的宽度就是100-10x2=80px。<br>
<strong>一些基础知识例子</strong></p>
<p>会用小属性层叠大属性。</p>
<p>padding:(上、右、下、左)（顺时针方向，用空格隔开。margin的道理也是一样的）</p>
<p>如果只写了三个值，则顺序为：上、右、下。左和右一样。</p>
<p>如果只写了两个值，padding: 30px 40px;	则顺序等价于：30px 40px 30px 40px;</p>
<p><img src="https://xin--images.oss-cn-hongkong.aliyuncs.com/images1/image-20220222231830403.png" alt="image-20220222231830403"></p>
<p>border</p>
<p><img src="https://xin--images.oss-cn-hongkong.aliyuncs.com/images1/image-20220222232607059.png" alt="image-20220222232607059"></p>
<h4 id="BFC块级格式化上下文">BFC块级格式化上下文</h4>
<p>BFC，就是一个与世隔绝的独立区域，不会互相影响</p>
<p>每一个BFC区域只包括其子元素，不包括其子元素的子元素。(这1点比较容易理解)</p>
<p>每一个BFC区域都是独立隔绝的,互不影响!(这点不太好理解，但是后续会使用代码验证)</p>
<p><strong>触发BFC的条件</strong></p>
<ul>
<li>body 根元素</li>
<li>浮动元素：float 除 none 以外的值</li>
<li>绝对定位元素：position (absolute、fixed)</li>
<li>display 为 inline-block、table-cells、flex</li>
<li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li>
</ul>
<p>满足任一即可</p>
<p><strong>解决外边距的塌陷问题(垂直塌陷)</strong>，<strong>包含塌陷</strong>，<strong>清除浮动</strong></p>
<h4 id="如何判断当前是否在iframe中"><strong>如何判断当前是否在iframe中</strong></h4>
<pre class="language-none"><code class="language-none">// 1
if (self.frameElement &amp;&amp; self.frameElement.tagName == "IFRAME") {
　　alert('在iframe中');
}

// 2
if (window.frames.length != parent.frames.length) {
　　alert('在iframe中');
}

// 3
if (self != top) { 
　　alert('在iframe中');
}
说明：

三种方式都是根据当前的窗口层级进行判断，
以上是针对有 &lt;frameset&gt; 或者 &lt;iframe&gt; 的页面，
self.frameElement 可以获取到当前的 iframe 节点（如果有的话），否则为null
 解释：window、top、parent、self 之间的联系和区别

window ： 当前窗口
top: 顶层窗口，针对有很多层的iframe
parent: 父级窗口，即当前窗口的上一层窗口
self: 当前窗口，和window、window.self  等价</code></pre>
<h4 id="响应式布局总结">响应式布局总结</h4>
<pre class="language-none"><code class="language-none">//  采用淘宝的lib-flexible的库,来做屏幕自适应处理.
 npm i lib-flexible -S
// 在项目中写css时会自动将rem转化为px,需要安装px2rem这个工具,安装:
  npm i px2rem-loader -D
  const loaders = [cssLoader, px2remLoader];
  // main.js中imoort，在index.html中加入下面的
  import  'lib-flexible'
 &lt;meta name='viewport' content='width=device-width , initial-scale=1.0'&gt;
</code></pre>
<h4 id="移动端适配的几种方案">移动端适配的几种方案</h4>
<p>早期网页设计采用<strong>静态布局</strong>，通过<code>&lt;meta&gt;</code>标签中的<code>applicable-device</code>应用设备标识识别移动设备，即<code>&lt;meta name = 'applicable-device' content = 'mobile'&gt;</code>，在<code>&lt;meta&gt;</code>标签中的<code>viewport</code>标签中设置<code>width</code>，通过<code>js</code>动态修改标签的<code>initial-scale</code>使得页面等比缩放，刚好占满整个屏幕。之前阅读过文章中有提到静态布局中页面各个元素采用<code>px</code>为单位，这种方案实现简单，不存在兼容性问题，但用户体验很不友好。</p>
<p>后面出现<strong>流式布局</strong>，使用百分比<code>%</code>定义宽度，高度使用<code>px</code>固定，根据可视区域大小实时进行尺寸调整，通常使用<code>max-width/min-width</code>控制尺寸范围过大或者过小。这种方案实现比较简单，但在大屏手机或横竖屏切换场景下可能会导致页面元素被拉伸变形，字体大小无法随屏幕大小发生变化。</p>
<p>顺应不同页面字体大小展现问题，出现了<strong>弹性布局</strong>。这种布局方案下，包裹文字的元素的尺寸采用<code>em/rem</code>为单位，页面主要划分区域的尺寸依据情况使用<code>px</code>、百分数或者<code>em/rem</code>。如一些高校的网站 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.jlu.edu.cn%2F">jlu</a>，页面的主要划分区域使用<code>px</code>和百分比，包裹文字的元素和文字采用<code>em</code>。</p>
<p>上面的这几种方案下，页面元素的大小按照屏幕分辨率进行适配调整，但是整体布局不变，对于<strong>响应式web设计</strong>，网页布局会随着访问它的视口及设备的不同呈现不同的样式，在实现上可能会以上多种方案的结合，同时搭配 <strong>媒体查询</strong> 技术使用，使得一个页面在多个终端 (PC, mobile, pad) 呈现满意效果，如 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fmashable.com%2F">mashable</a> 。</p>
<p>思路</p>
<ol>
<li>写页面时，按照设计稿写固定宽度，最后再统一缩放处理，在不同手机上都能用</li>
<li>按照设计稿的标准开发页面，在手机上部分内容根据屏幕宽度等比缩放，部分内容按需要变化，需要缩放的元素使用 rem, vw 相对单位，不需要缩放的使用 px</li>
<li>固定尺寸+弹性布局，不需要缩放</li>
</ol>
<h5 id="展开说说">展开说说</h5>
<h5 id="viewport-适配"><strong>viewport 适配</strong></h5>
<p><img src="https://pic2.zhimg.com/80/v2-e8f89ae102c6b739d9510630ccff5081_720w.jpg" alt="img"></p>
<p>根据设计稿标准（750px 宽度）开发页面，写完后页面及元素自动缩小，适配 375 宽度的屏幕</p>
<p>在 head 里设置如下代码</p>
<pre class="language-text" data-language="text"><code class="language-text">&lt;meta name="viewport" content="width=750,initial-scale=0.5"&gt;</code></pre>
<p>initial-scale = 屏幕的宽度 / 设计稿的宽度，为了适配其他屏幕，需要动态的设置 initial-scale 的值：</p>
<pre class="language-none"><code class="language-none">&lt;head&gt;
  &lt;script&gt;
    const WIDTH = 750
    const mobileAdapter = () =&gt; {
      let scale = screen.width / WIDTH
      let content = `width=${WIDTH}, initial-scale=${scale}, maximum-scale=${scale}, minimum-scale=${scale}`
      let meta = document.querySelector('meta[name=viewport]')
      if (!meta) {
        meta = document.createElement('meta')
        meta.setAttribute('name', 'viewport')
        document.head.appendChild(meta)
      }
      meta.setAttribute('content',content)
    }
    mobileAdapter()
    window.onorientationchange = mobileAdapter //屏幕翻转时再次执行
  &lt;/script&gt;
&lt;/head&gt;</code></pre>
<p>缺点就是边线问题，不同尺寸下，边线的粗细是不一样的（等比缩放后），全部元素都是等比缩放，实际显示效果可能不太好</p>
<h5 id="vw-适配（部分等比缩放）"><strong>vw 适配（部分等比缩放）</strong></h5>
<ol>
<li>开发者拿到设计稿（假设设计稿尺寸为750px，设计稿的元素标注是基于此宽度标注）</li>
<li>开始开发，对设计稿的标注进行转换，把px换成vw。比如页面元素字体标注的大小是32px，换成vw为 (100/750)*32 vw</li>
<li>对于需要等比缩放的元素，CSS使用转换后的单位</li>
<li>对于不需要缩放的元素，比如边框阴影，使用固定单位px</li>
</ol>
<p>关于换算，为了开发方便，利用自定义属性，CSS变量</p>
<pre class="language-none"><code class="language-none">&lt;head&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1"&gt;
  &lt;script&gt;
    const WIDTH = 750
    //:root { --width: 0.133333 } 1像素等于多少 vw
    document.documentElement.style.setProperty('--width', (100 / WIDTH)) 
  &lt;/script&gt;
&lt;/head&gt;</code></pre>
<p>注意此时，meta 里就不要去设置缩放了</p>
<p>业务代码里就可以写</p>
<pre class="language-text" data-language="text"><code class="language-text">header {
  font-size: calc(28vw * var(--width))
}</code></pre>
<p><strong>实现了按需缩放</strong></p>
<h5 id="rem-适配"><strong>rem 适配</strong></h5>
<ol>
<li>开发者拿到设计稿（假设设计稿尺寸为750px，设计稿的元素标是基于此宽度标注）</li>
<li>开始开发，对设计稿的标注进行转换</li>
<li>对于需要等比缩放的元素，CSS使用转换后的单位</li>
<li>对于不需要缩放的元素，比如边框阴影，使用固定单位px</li>
</ol>
<p><img src="https://xin--images.oss-cn-hongkong.aliyuncs.com/images1/202202251030048.png" alt="image-20220225103024885"></p>
<p>假设设计稿的某个字体大小是 40px, 手机屏幕上的字体大小应为 420/750*40 = 22.4px (体验好)，换算成 rem（相对于 html 根节点，假设 html 的 font-size = 100px,）则这个字体大小为 0.224 rem</p>
<p>写样式时，对应的字体设置为 0.224 rem 即可，其他元素尺寸也做换算…</p>
<p>但是有问题</p>
<p>举个 ，设计稿的标注 是40px，写页面时还得去做计算，很麻烦（全部都要计算）</p>
<p>能不能规定一下，看到 40px ,就应该写 40/100 = 0.4 rem,这样看到就知道写多少了（不用计算），此时的 html 的 font-size 就不能是 100px 了，应该为 (420*100)/750 = 56px，100为我们要规定的那个参数</p>
<p>根据不同屏幕宽度，设置 html 的 font-size 值</p>
<pre class="language-text" data-language="text"><code class="language-text">&lt;head&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1"&gt;
  &lt;script&gt;
    const WIDTH = 750 //设计稿尺寸
    const setView = () =&gt; {
      document.documentElement.style.fontSize = (100 * screen.width / WIDTH) + 'px'
    }
    window.onorientationchange = setView
    setView()
  &lt;/script&gt;
&lt;/head&gt;</code></pre>
<p>对于需要等比缩放的元素，CSS使用转换后的单位</p>
<pre class="language-text" data-language="text"><code class="language-text">header {
  font-size: .28rem;
}</code></pre>
<p>对于不需要缩放的元素，比如边框阴影，使用固定单位px</p>
<pre class="language-text" data-language="text"><code class="language-text">header &gt; span.active {
  color: #fff;
  border-bottom: 2px solid rgba(255, 255, 255, 0.3);
}</code></pre>
<p>假设 html 的 font size = 1px 的话，就可以写 28 rem 了，更方便了，但是浏览器对字体大小有限制，设为 1px 的话，在浏览器中是失效的，会以 12px（或者其他值） 做一个计算 , 就会得到一个很夸张的结果，所以可以把 html 写的大一些</p>
<p>使用 sass 库时</p>
<p>JS 处理还是一样的，但看着好看些</p>
<pre class="language-text" data-language="text"><code class="language-text">@function px2rem($px) {
  @return $px * 1rem / 100;
}

header {
  font-size: px2rem(28);
}</code></pre>
<p>以上的三种适配方案，都是<strong>等比缩放</strong>，放到 ipad 上时（设计稿以手机屏幕设计的），页面元素会很大很丑，有些场景下，并不需要页面整体缩放（viewport 自动处理的也很好了），所以有时只需要合理的布局即可。</p>
<h5 id="弹性盒适配（合理布局）"><strong>弹性盒适配（合理布局）</strong></h5>
<pre class="language-text" data-language="text"><code class="language-text">&lt;meta name="viewport" content="width=device-width"&gt;</code></pre>
<p>使用 flex 布局</p>
<pre class="language-text" data-language="text"><code class="language-text">section {
  display: flex;
}</code></pre>
<p>总结一下，什么样的页面需要做适配（等比缩放）呢</p>
<ul>
<li>页面中的布局是栅格化的</li>
</ul>
<p><img src="https://xin--images.oss-cn-hongkong.aliyuncs.com/images1/202202251031497.png" alt="image-20220225103139102"></p>
<p>换了屏幕后，到底有多宽多高很难去做设置，整体的都需要改变，所以需要整体的缩放</p>
<ul>
<li>
<p>头屏大图，宽度自适应，高度固定的话，对于不同的屏幕，形状就会发生改变（放到ipad上就变成长条了），宽度变化后，高度也要保持等比例变化</p>
<p><img src="https://xin--images.oss-cn-hongkong.aliyuncs.com/images1/202202251032820.png" alt="image-20220225103225694"></p>
</li>
</ul>
<p>以上所有的适配都是**宽度的适配，**但是在某些场景下，也会出现高度的适配</p>
<p>比如大屏，需要适配很多的电视尺寸，要求撑满屏幕，不能有滚动条，此时若换个屏幕</p>
<p><img src="https://xin--images.oss-cn-hongkong.aliyuncs.com/images1/202202251033268.png" alt="image-20220225103304113"></p>
<p>此时需要考虑小元素用 vh, 宽和高都用 vh 去表示，中间的大块去自适应，这就做到了大屏的适配，屏幕变小了，整体变小了（体验更好），中间这块撑满了屏幕</p>
<p>对于更复杂的场景，需要更灵活考虑，没有一种适配方式可以囊括所有场景。</p>
<h5 id="基于媒体查询的响应式设计">基于媒体查询的响应式设计</h5>
<p><strong>响应式设计</strong> 使得一个网站同时适配 <strong>多种设备</strong> 和 <strong>多个屏幕</strong>，让网站的布局和功能随用户的使用环境（屏幕大小、输出方式、设备/浏览器能力而变化），使其视觉合理，交互方式符合习惯。如使得内容区块可伸缩与自由排布，边距适应页面尺寸，图片适应比例变化，能够自动隐藏/部分显示内容，能自动折叠导航和菜单。</p>
<h4 id="原理">原理</h4>
<blockquote>
<p>主要实现是通过 <strong>媒体查询</strong>，通过给不同分辨率的设备编写不同的样式实现响应式布局，用于解决不同设备不同分辨率之间兼容问题，一般是指PC、平板、手机设备之间较大的分辨率差异。实现上不局限于具体的方案，通常结合了 <strong>流式布局</strong> <code>+</code> <strong>弹性布局</strong> 方案。比如给小屏幕手机设置<code>@2x</code>图，为大屏手机设置<code>@3x</code>图</p>
</blockquote>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">@media only screen <span class="token function">and</span> <span class="token punctuation">(</span><span class="token parameter">min<span class="token operator">-</span>width<span class="token operator">:</span> <span class="token number">375</span>px</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    样式<span class="token number">1</span>
<span class="token punctuation">}</span>
@media only screen <span class="token function">and</span> <span class="token punctuation">(</span><span class="token parameter">min<span class="token operator">-</span>width<span class="token operator">:</span> <span class="token number">750</span></span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    样式<span class="token number">2</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="优势">优势</h4>
<blockquote>
<p>能够使网页在不同设备、不同分辨率屏幕上呈现合理布局，不仅仅是样式伸缩变换</p>
</blockquote>
<h4 id="不足">不足</h4>
<blockquote>
<ul>
<li>要匹配足够多的设备与屏幕，一个web页面需要多个设计方案，工作量比较大<br>
…</li>
<li>通过媒体查询技术需要设置一定量的断点，到达某个断点前后的页面发生显著变化，用户体验不太友好</li>
</ul>
</blockquote>
<pre class="language-none"><code class="language-none">当创建一个响应式网站，或者非响应式网站变成响应式的时候，首先要关注元素的布局。我在创建响应式布局的时候习惯先写非响应式布局，页面固定宽度大小，我觉得这个对在座的各位没有任何难度。如果完成了非响应式那么我在去添加媒体查询（Media Query)和响应式代码。这种操作更容易实现响应式特性。
1.布局及设置meta标签
当你完成当你已经完成了无响应的网站，做的第一件事是在你的 HTML 页面，粘贴下面的代码到标签之间。

大多数移动浏览器将HTML页面放大为宽的视图（viewport）以符合屏幕分辨率。你可以使用视图的meta标签来进行重置。下面的视图标签告诉浏览器，使用设备的宽度作为视图宽度并禁止初始的缩放。在标签里加入这个meta标签。
&lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"&gt;
    &lt;!-- width=device-width ：表示宽度是设备屏幕的宽度
    initial-scale=1.0：表示初始的缩放比例
    minimum-scale=0.5：表示最小的缩放比例
    maximum-scale=2.0：表示最大的缩放比例
    user-scalable=yes：表示用户是否可以调整缩放比例 --&gt;
    [1]（user-scalable = no 属性能够解决 iPad 切换横屏之后触摸才能回到具体尺寸的问题。 ）
2.通过媒体查询来设置样式media query
media query 是响应式设计的核心，它能够和浏览器进行沟通，告诉浏览器页面如何呈现，假如一个终端的分辨率小于980px，那么可以这样写
    @media screen and (max-width:980px){
         #head { … }
         #content { … }
         #footer { … }
    }
这里面的样式会覆盖掉之前所定义的样式。

3.设置多种视图宽度
假如我们要兼容ipad和iphone视图，我们可以这样设置：
/** iPad **/
@media only screen and (min-width: 768px) and (max-width: 1024px) {}
/** iPhone **/
@media only screen and (min-width: 320px) and (max-width: 767px) {}
ps:@media screen 和 @media screen only的区别:

only用来定某种特别的媒体类型。对于支持Media Queries的移动设备来说，如果存在only关键字，移动设备的Web浏览器会忽略only关键字并直接根据后面的表达式应用样式文件。对于不支持Media Queries的设备但能够读取Media Type类型的Web浏览器，遇到only关键字时会忽略这个样式文件。

一些注意的
宽度需要使用百分比
    #head { width: 100% }
    #content { width: 50%; }
2.处理图片缩放的方法

简单的解决方法可以使用百分比，但这样不友好，会放大或者缩小图片。那么可以尝试给图片指定的最大宽度为百分比。假如图片超过了，就缩小。假如图片小了，就原尺寸输出。
 img { width: auto; max-width: 100%; }

</code></pre>
<h4 id="类名冲突怎么解决？">类名冲突怎么解决？</h4>
<pre class="language-none"><code class="language-none">使用css-loader来处理css文件，它就实现了css module的思想（css-loader使用在webpack常用插件中有讲述）。要启用css module，需要将css-loader的配置modules设置为true。

css module原理非常简单，css-loader会将样式中的类名进行转换，转换为一个唯一的hash值。由于hash值是根据模块路径和类名生成的，因此，不同的css模块，哪怕具有相同的类名，转换后的hash值也不一样。
使用css-loader来处理css文件，它就实现了css module的思想（css-loader使用在webpack常用插件中有讲述）。要启用css module，需要将css-loader的配置modules设置为true。
因此css-loader使用css module后，源代码的类名和最终生成的类名是不一样的，而开发者只知道自己写的源代码中的类名，并不知道最终的类名是什么，css-loader会导出二者的对应关系，但还包括了很多其他信息。而style-loader就是去除其他信息，仅暴露类名和对应生成的hash值


因为css-loader转换css代码后，交给style-loader进习性处理，sytle-loader是用一段js代码，将样式加到style文件中。而我们通常更需要的是生成一个css文件。于是就有了库mini-css-extract-plugin，这个库提供了一个plugin和一个loader：

plugin：负责生成css文件
loader：负责记录要生成的css文件的内容，同时导出开启css-module后的样式对象
</code></pre>
<h4 id="面试题-2">面试题</h4>
<ol>
<li>下列浏览器对应的hack方式正确的有：A<br>
A. IE6: _property:value<br>
B. IE6/7/8: *property:value<br>
C. IE8: *property:value<br>
D. IE9: property:value\9</li>
</ol>
<p>分析：这道题考察的是css hack。css hack的目的就是使你的css代码兼容不同的浏览器，一般有两种方式，条件注释法、类内属性注释法。 本题显然是运用的类内属性注释法 ： _ ie6识别 * ie6/7识别 \9 ie6-10都能识别。</p>
<ol start="2">
<li>css实现单行文本超出显示….<br>
overflow:hidden;<br>
text-overflow:ellipsis;<br>
white-space: nowrap;</li>
<li></li>
</ol>
<h3 id="js基础">js基础</h3>
<h4 id="MVVM">MVVM</h4>
<p><strong>如何理解MVVM？</strong></p>
<p>MVVM是一种基于前端开发的架构模式，它起源于后端MVC框架，是为了适应日渐复杂的前端业务而生。</p>
<p>因为后端MVC模式并不完全适合前端场景，所以前端开拓者们将MVC中的C - Controller，变形为VM - ViewModel。</p>
<p>VM在MVVM模式中相当于一座桥梁，解耦了视图和数据，同时又连接着视图和数据。视图通过事件绑定的方式改变数据，数据通过数据绑定的方式改变视图，它们都是通过VM来进行交互的。</p>
<p>MVC:model是数据模型，View 是视图；Controller 是用来控制Model的读取、存储，以及如何在 View上 展示数据，更新数据的逻辑控制器。View接收用户的输入操作，传递给Controller进行业务逻辑处理，Model实现数据持久化，并将结果反馈给View，完成一次MVC模式。目前常见的 iOS 和 Android 开发，SDK 和与其搭配的 IDE 工具都是默认以 MVC 的方式来使用。缺点：每次数据更新之后，都需要操作dom, 影响开发效率;</p>
<p>没有办法独立开发，必须等接口做好了才能往下开发。前端太过依赖于后台</p>
<p>MVVM将“数据模型数据双向绑定”的思想作为核心，因此在View和Model之间没有联系，通过ViewModel进行交互，而且Model和ViewModel之间的交互是双向的，因此视图的数据的变化会同时修改数据源，而数据源数据的变化也会立即反应到View上。使用MVC的 目的 就是 将M和V的代码分离</p>
<p><strong>为什么会出来MVVM</strong>？</p>
<ul>
<li>开发者在代码中大量调用相同的 DOM API, 处理繁琐 ，操作冗余，使得代码难以维护。</li>
<li>大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。</li>
<li>当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致 Model 发生变化，开发者同样需要将变化的数据同步到Model 中，这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。</li>
</ul>
<h4 id="vue没有完全遵循MVVM模式的原因">vue没有完全遵循MVVM模式的原因</h4>
<p>Vue.js 可以说是MVVM 架构的最佳实践，VUE并没有完全遵循MVVM，专注于 MVVM 中的 ViewModel，不仅做到了数据双向绑定，而且也是一款相对比较轻量级的JS 库，API 简洁，很容易上手</p>
<p>原因一: mvvm是指 “模型-视图-视图模型”, 应该是让"模型"和"视图"实现完全的解耦, 但是vue中提供了一个属性: ref, 通过ref可以拿到dom对象，通过ref直接去操作视图。这一点上，违背了mvvm;</p>
<p>原因二: 如下图, 结构上, “数据层"包含在了"数据模型层”, 这两个部分没有完全独立出来</p>
<p><img src="https://pic3.zhimg.com/80/v2-1212d374015876d55c9b3dca99ecdfba_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-aec1cf60636ed9526caac95aff78fa47_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-a22011409fa3dbac0332bca9ee4c108f_720w.jpg" alt="img"></p>
<h4 id="一些基础">一些基础</h4>
<p>concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。<em>array1</em>.concat(<em>array2</em>,<em>array3</em>,…,<em>arrayX</em>)</p>
<h4 id="style的display-和visibility区别">style的display 和visibility区别</h4>
<p>JavaScript中的 <strong>visibility</strong> 属性也用于隐藏元素。 <strong>style.display</strong> 和 <strong>style.visibility</strong> 之间的区别是使用 <strong>visibility：隐藏</strong>标签时不可见，但已分配空间。使用 <strong>显示：无</strong>，标签也不可见，但页面上没有分配空间。</p>
<h4 id="数据类型">数据类型</h4>
<p>javascript没有整型变量这个概念，变量可以被赋值为任何类型的值。数值类型只有Number，不区分整数、浮点、长整等，直接赋值为一个整数即可。如果使用过程中必须用到整数，可以通过Math.round(number)，parseInt(string)等函数取整，再使用。</p>
<h5 id="0-1-0-2-0-3">0.1+0.2 !=0.3</h5>
<p>因为计算机中数字是以多位二进制的方式来存储的，在JS中数字采用的<code>IEEE 754</code>的双精度标准进行存，像0.5在二进制位中就是0.1，0.375是1/4+1/8就是0.011，只有能表示为x/2^n的数能被整除，才能有限表示，，其余小数都是以近似值得方式存在的。所以像0.1这样的数值用二进制表示你就会发现无法整除，最后算下来会是 0.000110011…由于存储空间有限，最后计算机会舍弃后面的数值，所以我们最后就只能得到一个近似值。0.1和0.2都是近似表示的，在他们相加的时候，两个近似值进行了计算，导致最后得到的值是0.30000000000000004，此时对于JS来说，其不够近似于0.3，于是就出现了0.1 + 0.2 != 0.3 这个现象。</p>
<p>最常用的方法就是将浮点数转化成整数计算。因为整数都是可以精确表示的。</p>
<pre class="language-none"><code class="language-none">1：parseFloat((0.1 + 0.2).toFixed(10)

2：四舍五入法：Number(0.1+0.2).toFixed(2)

3：Number.EPSILON 实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。

Number.EPSILON=(function(){   //解决兼容性问题
        return Number.EPSILON?Number.EPSILON:Math.pow(2,-52);
})();
function numbersequal(a,b){ 
    return Math.abs(a-b)&lt;Number.EPSILON;
 }
 var a=0.1+0.2, b=0.3;
 console.log(numbersequal(a,b)); //这里就为true了
 4：把计算数字 提升 10 的N次方 倍 再 除以 10的N次方。N&gt;1.</code></pre>
<h4 id="undefined">undefined</h4>
<p>以声明，未赋值</p>
<p>方法的返回值</p>
<p>对象上某个没有的值</p>
<h4 id="js中arguments">js中arguments</h4>
<p>其实Javascript并没有重载函数的功能，但是Arguments对象能够模拟重载。Javascrip中每个函数都会有一个Arguments对象实例arguments，它引用着函数的实参，可以用数组下标的方式"[]"引用arguments的元素。arguments.length为函数实参个数，arguments.callee引用函数自身。</p>
<h4 id="和-的区别">=,==和===的区别</h4>
<ul>
<li>=是赋值的意思，是让左边的值等于右边的值，比如：var a=1;那么现在alert(a)就是1，当然右边可以是变量，如：var a=1; var b也是1;</li>
<li>==是判断等于的意思，返回的是一个布尔值，如：alert(1==1);将返回true，因为1等于1，如果 alert(1==‘1’);也返回true，虽说后面的1是字符串类型，但是==是不判断类型的，所以还是true，如果：alert(1==‘2’)就是false了，因为1不等于2;</li>
<li>===也是判断的，但是它要比==判断的严谨一点，它的判断必须什么都相等，比如说类型，值;如： alert(1===1);将返回true，因为它们都是1，而且都是数字</li>
<li>类型，如果：alert(1===‘1’);将返回false，因为前面的1是数字类型，后面的1是字符串类型。</li>
</ul>
<p><strong>面试题</strong></p>
<p>以下表达式中返回结果是true的有：ABC</p>
<p>A. false == ‘0’<br>
B. ‘123’ ==123<br>
C. new String(‘123’) == ‘123’<br>
D.null == false</p>
<h4 id="数组的splice方法">数组的splice方法</h4>
<p>splice(start,deleteCnt,args) 中的start表示开始操作下标，deleteCnt表示从开始下标开始（包括该元素)要删除的元素个数，删除操作返回删除的元素。args表示用来替换删除掉的那些元素（可以有多个参数)，start和deleteCnt必须为数字，如果不是数字尝试转换，转换失败当做0来处理。splice必须至少有一个start元素，否则不做任何操作。deleteCnt不存在表示删除start及后面的全部元素（IE下，取0不做删除)。start可以为负数，表示从数组右边结尾处开始计算。deleteCnt如果为负数不做删除，因为不可能删除负个元素。</p>
<h5 id="splice-方法和slice-方法">splice()方法和slice()方法</h5>
<p><strong>slice(start,end) 返回你选择的某段数组元素，不会修改原数组</strong></p>
<p>**①：**start表示从何处开始选取，end表示从何处开始结束选取，表示一个选取的范围</p>
<p>**②：**start可以为负数，此时它规定从数组尾部开始算起的位置。也就是-1 ，指最后一个元素，-2 指倒数第二个元素，以此类推</p>
<p>③：**end如果没有被指定参数，数组会包含从 start 到最后一个数组元素的所有元素</p>
<p>​	④：slice()方法不会修改数组本身，而是返回所选取范围的数组元素。如果想删除数组中的某一个元素，需要使用splice()</p>
<p>**splice()定义：**从数组中添加或删除元素，然后返回被删除的数组元素，会修改原数组</p>
<pre class="language-none"><code class="language-none">var oldArr3=[1,2];
oldArr3.splice(1,1)–&gt;2(从下标1 开始删除1个元素，即删除2，所以删除后oldArr3–&gt;[1])
oldArr3.splice(-1,0,3)–&gt;”"(从下标-1即2元素开始删除0个元素，然后添加元素3，所以操作后oldArr3–&gt;[1,3,2])</code></pre>
<p>splice(index，howmany，i**tem1,…,itemX)</p>
<p>**①：**index表示从什么位置开始添加或删除数组元素</p>
<p>**②：**howmany表示删除的元素数量，如果为0，则表示不删除数组元素</p>
<p><strong>③：i</strong>tem1,…,itemX表示新增的数组元素</p>
<p>④：**splice()方法会改变原始数组</p>
<h4 id="数组和对象的遍历">数组和对象的遍历</h4>
<h5 id="数组遍历-for-forEach-map-for…of">数组遍历(for,forEach,map,for…of)</h5>
<p><strong>1，普通for循环，经常用的数组遍历</strong></p>
<pre class="language-none"><code class="language-none">var arr = [1,2,0,3,9];
 for ( var i = 0; i &lt;arr.length; i++){
    console.log(arr[i]);
}</code></pre>
<p><strong>2，优化版for循环:</strong></p>
<p>使用变量，将长度缓存起来，避免重复获取长度，数组很大时优化效果明显</p>
<pre class="language-none"><code class="language-none">for(var j = 0,len = arr.length; j &lt; len; j++){
    console.log(arr[j]);
}</code></pre>
<p><strong>3，forEach，数组自带的循环，主要功能是遍历数组</strong></p>
<p>arr.forEach(function(value,i){<br>
　　console.log(‘forEach遍历:’+i+‘–’+value);</p>
<p>})</p>
<p>forEach这种方法也有一个小缺陷：你不能使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/break">break</a>语句中断循环，也不能使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/return">return</a>语句返回到外层函数。</p>
<p><strong>4,map遍历，map即是 “映射”的意思 用法与 forEach 相似</strong></p>
<pre class="language-none"><code class="language-none">arr.map(function(value,index){
    console.log('map遍历:'+index+'--'+value);
});</code></pre>
<p>map遍历支持使用return语句，支持return返回值</p>
<pre class="language-none"><code class="language-none">var temp=arr.map(function(val,index){
  console.log(val);  
  return val*val           
})
console.log(temp);  </code></pre>
<p>forEach、map都是ECMA5新增数组的方法，所以ie9以下的浏览器还不支持</p>
<p><strong>5，for-of遍历</strong></p>
<p>for…of为ES6新增的方法，主要来遍历可迭代的对象（包括Array, Map, Set, arguments等），它主要用来获取对象的属性值，而for…in主要获取对象的属性名。</p>
<p>[<img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码">](javascript:void(0);)</p>
<pre class="language-none"><code class="language-none">var arr1 = [1, 2, 3]
for (let i of arr1){
    console.log(i)
}

// 遍历普通对象报错
var obj2 = {fname:1, name2:22}
for(let val of obj2){
    console.log(val)
}</code></pre>
<p>[<img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码">](javascript:void(0);)</p>
<ul>
<li>for-of这个方法避开了for-in循环的所有缺陷</li>
<li>它可以正确响应break、continue和return语句</li>
</ul>
<p>for-of循环支持数组，还支持类对象(例如DOM <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/NodeList">NodeList对象</a>)，字符串，map对象，set对象</p>
<p>for -of遍历数组，遍历的结果是数组的值</p>
<p>for-of不适合遍历普通对象，但可以通过Array.from()方法转换为类数组或可迭代对象</p>
<h5 id="对象遍历">对象遍历</h5>
<p>1，Object.keys()遍历对象</p>
<p>1.1，在实际开发中，我们有时需要知道对象的所有属性,Object.keys()，传入对象，返回属性名并放在数组里<br>
var obj = {‘a’:‘123’,‘b’:‘345’}<br>
console.log(Object.keys(obj))<br>
// [“a”, “b”]<br>
1.2，Object.keys().forEach() 遍历对象，把对象的属性名转成数组，可与数组遍历结合使用<br>
复制代码<br>
var person = {<br>
name: ‘hhh’,<br>
age:‘20’,<br>
sex:‘男’,<br>
home:‘china’<br>
}</p>
<pre><code>var keys = Object.keys(person).forEach((e) =&gt;{
    console.log('person', e, ':', person[e])
})

// Object.keys 遍历对象，把对象的属性名转成数组，可与数组遍历结合使用
var keys2 = Object.keys(person)
console.log(keys2)
//  ["name", "age", "sex", "home"]
</code></pre>
<p>复制代码</p>
<p>2，for-in遍历对象</p>
<p>for…in遍历对象，它遍历的是属性名<br>
会遍历实例的属性，还会遍历整个原型链，这可能不是你所期望的结果，然后从性能角度上看Object.keys会更优。<br>
复制代码<br>
var obj = {‘a’:‘123’,‘b’:‘345’}<br>
for (let key in obj){<br>
console.log(key ,obj[key])<br>
}<br>
// a 123<br>
// b 345<br>
复制代码<br>
for-in是为遍历对象而设计的，不适用于遍历数组。</p>
<p>遍历数组的缺点：for-in遍历的index值"0",“1”,"2"等是字符串</p>
<pre class="language-none"><code class="language-none">for (var index in arr){
    console.log(arr[index]);
    console.log(index);
}</code></pre>
<p>for-in遍历，会把属性名排序</p>
<p>[<img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码">](javascript:void(0);)</p>
<pre class="language-none"><code class="language-none">let obj2 = {b:2, a:'11', 1:'ok'}
for (let key in obj2) {
    console.log(key)
}
// 1
// b
// a</code></pre>
<p>[<img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码">](javascript:void(0);)</p>
<p>for…in总结：</p>
<p><strong>1、for in遍历对象时，会遍历实例的属性+还遍历原型中可枚举的属性</strong></p>
<p><strong>2、for in不适合遍历数组，遍历数组遍历的是下标，下标类型是 字符串</strong></p>
<p><strong>3，for in遍历会以任意顺序遍历对象的属性名</strong></p>
<h4 id="for…in-和for…-of">for…in 和for… of</h4>
<p>for-in是ES5标准，遍历的是key（可遍历对象、数组或字符串的key）；for-of是ES6标准，遍历的是value（可遍历对象、数组或字符串的value）</p>
<pre class="language-none"><code class="language-none">for (var key in myObject) {
　　if（myObject.hasOwnProperty(key)){
　　　　console.log(key);
　　}
}</code></pre>
<p><strong>所以for-in更适合遍历对象，通常是建议不要使用for-in遍历数组</strong>。</p>
<p><strong>for-of循环</strong></p>
<p>for-of可以简单、正确地遍历数组（不遍历原型method和name）。</p>
<pre class="language-none"><code class="language-none">var myArray = [1, 2, 4, 5, 6, 7];
myArray.name = "数组";
myArray.getName = function() { return this.name; }
for (var value of myArray) {
    console.log(value);
}</code></pre>
<p>区别总结</p>
<p>简单总结就是，for in遍历的是数组的索引（即键名），而for of遍历的是数组元素值。</p>
<p>for-in总是得到对象的key或数组、字符串的下标。</p>
<p>for-of总是得到对象的value或数组、字符串的值，另外还可以用于遍历Map和Set。</p>
<pre class="language-none"><code class="language-none">var set = new Set();
set.add("a").add("b").add("d").add("c");

// 遍历Set
for (let s of set) {
    console.log(s);
}

var map = new Map();
map.set("a", 1).set("b", 2).set(999, 3);

// 遍历Map
for(let [k, v] of map) {
    console.log(k, v);
}</code></pre>
<h4 id="Symbol">Symbol</h4>
<p><img src="https://xin--images.oss-cn-hongkong.aliyuncs.com/images1/202203030131326.png" alt="image-20220303013157858"></p>
<h4 id="对象数组去重">对象数组去重</h4>
<p>去除数组中所有对象的相同的一个键值</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> tempArr1 <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>id<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>name<span class="token operator">:</span><span class="token string">'apple'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>id<span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">,</span>name<span class="token operator">:</span><span class="token string">'pen'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>id<span class="token operator">:</span><span class="token number">3</span><span class="token punctuation">,</span>name<span class="token operator">:</span><span class="token string">'book'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>id<span class="token operator">:</span><span class="token number">3</span><span class="token punctuation">,</span>name<span class="token operator">:</span><span class="token string">'mouse'</span><span class="token punctuation">}</span>
<span class="token punctuation">]</span> 
tempArr1 <span class="token operator">=</span>  tempArr1<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span>index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token comment">// id等于自身的就返回后，再通过index判断是不是同一项</span>
    <span class="token keyword">return</span> tempArr1<span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span><span class="token parameter">item1</span> <span class="token operator">=&gt;</span>item1<span class="token punctuation">.</span>id<span class="token operator">==</span>item<span class="token punctuation">.</span>id<span class="token punctuation">)</span> <span class="token operator">==</span> index
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
<h4 id="数组扁平化：">数组扁平化：</h4>
<pre class="language-none"><code class="language-none"></code></pre>
<h4 id="深拷贝和浅拷贝，实现深拷贝">深拷贝和浅拷贝，实现深拷贝</h4>
<p>浅拷贝和深拷贝都只针对于引用数据类型，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存，所以当一个对象发生变化时，另一个对象随之改变；</p>
<p>深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象；</p>
<p>区别：浅拷贝只复制对象的第一层属性、深拷贝可以对对象的属性进行递归复制；</p>
<h5 id="深拷贝实现的方法">深拷贝实现的方法</h5>
<pre class="language-none"><code class="language-none">objClone = JSON.parse(JSON.stringfy(obj))</code></pre>
<p>JSON.parse()：JSON-&gt;JS。JSON.stringfy()：JS-&gt;JSON</p>
<h5 id="实现一个深拷贝">实现一个深拷贝</h5>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">deepClone</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// let objClone = obj.constructor === Array ? []:{}</span>
　　<span class="token keyword">let</span> objClone <span class="token operator">=</span>  Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
　　　　<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span><span class="token punctuation">{</span>
　　　　　　<span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
　　　　　　　　objClone<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
　　　　　　<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
　　　　　　　　objClone<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
　　　　　　<span class="token punctuation">}</span>
　　　　<span class="token punctuation">}</span>
　　<span class="token keyword">return</span> objClone<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h5 id="JSON格式">JSON格式</h5>
<p><img src="https://xin--images.oss-cn-hongkong.aliyuncs.com/images1/202203030040673.png" alt="image-20220303004032328"></p>
<p>null，十进制数字，双引号的值，true，false，数组，对象。undefined,NaN,Infinity，大写都不行</p>
<h4 id="判断是一个数组还是一个对象">判断是一个数组还是一个对象</h4>
<p>instanceof，Arrray.isArray()</p>
<pre class="language-none"><code class="language-none">var arr = []
arr instanceof Array // true</code></pre>
<h4 id="typeof和instanceof区别">typeof和instanceof区别</h4>
<p>typeof用于检测基本类型，当他检测引用类型array和object时，得到的都是“object”。因此，我们需要instanceof。</p>
<p>instanceof用于检测引用类型，它可以区分出array和object。其内部是通过原型链来实现的，比如 arr1 instanceof Array ，他会在arr1的原型链上查找，这里只查找一层，arr1.<strong>proto</strong> == Array.prototype，返回true。</p>
<h4 id="var-const-let的区别">var,const,let的区别</h4>
<p>总结：</p>
<p>var存在声明提升，变量覆盖的·问题，同时它没有块级作用域</p>
<p>const一旦声明必须赋值,不能使用null占位；声明后不能再修改 ；如果声明的是复合类型数据，可以修改其属性，支持let的其它属性</p>
<p>let有块级作用域，，函数内部使用let定义后，对函数外部无影响。</p>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>ES6相关面试题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
      <span class="token comment">// var let const</span>
      <span class="token comment">// 1. 声明提升 =&gt; 先上车后买票</span>
    <span class="token comment">//   console.log(num)  // undefined</span>
      <span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">123</span>

      <span class="token comment">// 2. 变量覆盖 =&gt; 套牌车</span>
      <span class="token keyword">var</span> num1 <span class="token operator">=</span> <span class="token number">12</span>
      <span class="token keyword">var</span> num1 <span class="token operator">=</span> <span class="token number">34</span>
    <span class="token comment">//   console.log(num1) // 34</span>

    <span class="token comment">//   var obj = {}  </span>
    <span class="token comment">//   obj = ''</span>
    <span class="token comment">// 3. 没有块级作用域 =&gt; 红杏出墙</span>
    <span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// console.log(i)</span>
    <span class="token punctuation">}</span>
    <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">// 1. const声明之后必须赋值 否则就报错</span>
    <span class="token comment">// 2. 定义的值不能修改，否则报错</span>
    <span class="token comment">// 3. 支持let的其它属性</span>
    
    <span class="token keyword">const</span> <span class="token constant">DEMO</span> <span class="token operator">=</span> <span class="token number">123</span>
    <span class="token comment">// demo = 456</span>
    <span class="token comment">// console.log(demo)</span>

    <span class="token comment">// 解构相关</span>
    <span class="token comment">// let a = 1;</span>
    <span class="token comment">// let b = 2;</span>
    <span class="token comment">// [a, b] = [b, a]</span>
    <span class="token comment">// console.log(a, b)</span>
    
    <span class="token comment">// let arr = [12, 43, 23, 12, 43, 55]</span>
    <span class="token comment">// let item = [...new Set(arr)]</span>
    <span class="token comment">// console.log(item)</span>

    <span class="token comment">// 标杆 =&gt; 构造函数同步执行</span>
    <span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token comment">// .then() 异步执行</span>
    promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>

    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre>
<h5 id="经典题">经典题</h5>
<pre class="language-none"><code class="language-none">以下代码执行后a、b的值分别是（c）
var a=0;
var b=false || a++;
A、1,1
B、0,0
C、1,0
D、0，false

分析：在运算过程中，首先js 会将 &amp;&amp; 或|| 两边的值转成Boolean 类型，然后再算值 ，&amp;&amp;运算如果返回true，则取后面的值，如果|| 返回true,则取前面的值 。而其中数值转换成boolean 的规则 是：

对象、非零整数、非空字符串返回true,

其它为false ;
在本题中a++结果是0，a是1。||两边都为false,所以结果也就是false。按照上面所说的如果||返回true,则取前面的值。所以b的值就取后面的值0，故选c。</code></pre>
<h4 id="对象继承">对象继承</h4>
<h5 id="Object-create">Object.create</h5>
<p>已知var obj = Object.create({a:1}),则obj.hasOwnproperty(‘a’)返回的结果是：(false).</p>
<p>分析：Object.create(proto [, propertiesObject ]) 是E5中提出的一种新的对象创建方式，第一个参数是要继承的原型，如果不是一个子函数，可以传一个null，第二个参数是对象的属性描述符，这个参数是可选的。hasOwnproperty方法是判断一个属性是否是定义在对象本身，如果是则返回true，否则返回false。很显然obj是在原型的基础上创建的。</p>
<h4 id="作用域">作用域</h4>
<p>作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在JavaScript中，变量的作用域有全局作用域和局部作用域两种。</p>
<p><strong>编程语言作用域</strong></p>
<ol>
<li>静态作用域（由程序定义的位置决定）</li>
<li>动态作用域（由程序运行的时刻决定）</li>
</ol>
<p><strong>javascript的作用域：</strong></p>
<p>在JavaScript中，变量的作用域有全局作用域和局部作用域两种。</p>
<ol>
<li>全局作用域：在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域：</li>
</ol>
<p>（1）最外层函数和在最外层函数外面定义的变量拥有全局作用域</p>
<p>​		（2）所有末定义直接赋值的变量自动声明为拥有全局作用域</p>
<p>​		（3）所有window对象的属性拥有全局作用域</p>
<p>2.局部作用域：局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部</p>
<p><strong>因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。</strong></p>
<ol>
<li>Js使用词法作用域（静态作用域）；</li>
<li>Js没有块级作用域；</li>
<li>ES5中使用词法环境管理静态作用域。</li>
</ol>
<p>js的预定义机制：就是js解释器会先对var定义的变量进行初始化，应该说只是起了定义的作用但并没赋值。</p>
<pre class="language-none"><code class="language-none">实例1：
var value = 1;

function foo() {
    console.log(value);
}

function bar() {
    var value = 2;
    foo();
}

bar(); //1

// 结果是 ???
假设JavaScript采用静态作用域，让我们分析下执行过程：
执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。
假设JavaScript采用动态作用域，让我们分析下执行过程：
执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。
前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 1。

var foo=1; 
function bar( ) { 
  foo = 10;
} 
bar( ); 
alert(foo);// 10



// 实例2：
var x = "globol value"; 
var getValue = function(){
 alert(x);   
var x = "local value";
 alert(x);    
 }
getValue();
运行的结果是：undefined/local value
// 实例3：
var x=10;
  function foo(){
   alert(x);
   var x=20;//无论x的值为多少，最后结果都是undefined
  }
  function bar(){
   foo();
  }
  bar()；
  
  
  console.log(a) // undefined
  var a = 0
  function fun(num1,num2) {
  	console.log(a) // undefined
  	var a = num1+num2
  	console.log(a) // 30
  }
  fun(10,20)
  console.log(a) // 0</code></pre>
<h4 id="作用域链">作用域链</h4>
<p>JavaScript里一切都是对象。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是[[Scope]]，，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。</p>
<p>当一个函数创建后，它的作用域链会被创建此函数的作用域中可访问的数据对象（如全局对象）填充。</p>
<p><img src="https://xin--images.oss-cn-hongkong.aliyuncs.com/images1/202203010946677.png" alt="image-20220301094634370"></p>
<p>执行此函数时会创建一个称为“运行期上下文(execution context)”的内部对象，运行期上下文定义了函数执行时的环境。每个运行期上下文都有自己的作用域链，用于标识符解析，当运行期上下文被创建时，而它的作用域链初始化为当前运行函数的[[Scope]]所包含的对象。</p>
<p>这些值按照它们出现在函数中的顺序被复制到运行期上下文的作用域链中。它们共同组成了一个新的对象，叫“活动对象(activation object)”，该对象包含了函数的所有局部变量、命名参数、参数集合以及this，然后此对象会被推入作用域链的前端，当运行期上下文被销毁，活动对象也随之销毁。新的作用域链如下图所示：</p>
<p><img src="https://xin--images.oss-cn-hongkong.aliyuncs.com/images1/202203010948419.png" alt="image-20220301094840147"></p>
<p>在函数执行过程中，**每遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取和存储数据。**该过程从作用域链头部，也就是从活动对象开始搜索，查找同名的标识符，如果找到了就使用这个标识符对应的变量，如果没找到继续搜索作用域链中的下一个对象，如果搜索完所有对象都未找到，则认为该标识符未定义。函数执行过程中，每个标识符都要经历这样的搜索过程。</p>
<h5 id="代码优化">代码优化</h5>
<p>分析：从作用域链的结构可以看出，在运行期上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。因为全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在<strong>编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。</strong></p>
<p>函数每次执行时对应的运行期上下文都是独一无二的，所以多次调用同一个函数就会导致创建多个运行期上下文，当函数执行完毕，执行上下文会被销毁。每一个运行期上下文都和一个作用域链关联。一般情况下，在运行期上下文运行的过程中，其作用域链只会被 with 语句和 catch 语句影响。</p>
<h5 id="改变作用域链-with-catch">改变作用域链(with/catch)</h5>
<p>with语句是对象的快捷应用方式，用来避免书写重复代码。当代码运行到with语句时，运行期上下文的作用域链临时被改变了。一个新的可变对象被创建，它包含了参数指定的对象的所有属性。这个对象将被推入作用域链的头部，这意味着函数的所有局部变量现在处于第二个作用域链对象中，因此访问代价更高了。</p>
<p>另外一个会改变作用域链的是try-catch语句中的catch语句。当try代码块中发生错误时，执行过程会跳转到catch语句，然后把异常对象推入一个可变对象并置于作用域的头部。在catch代码块内部，函数的所有局部变量将会被放在第二个作用域链对象中。请注意，一旦catch语句执行完毕，作用域链机会返回到之前的状态。try-catch语句在代码调试和异常处理中非常有用，因此不建议完全避免。你可以通过优化代码来减少catch语句对性能的影响。一个很好的模式是将错误委托给一个函数处理。优化后的代码，handleError方法是catch子句中唯一执行的代码。该函数接收异常对象作为参数，这样你可以更加灵活和统一的处理错误。由于只执行一条语句，且没有局部变量的访问，作用域链的临时改变就不会影响代码性能了。</p>
<h4 id="函数">函数</h4>
<p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=function&amp;spm=1001.2101.3001.7020">function</a> 这个关键字，既可以当做<strong>语句</strong>，也可以当做<strong>表达式</strong></p>
<pre class="language-none"><code class="language-none">//语句
function fn() {};

//表达式
var fn = function (){};
var id = 'GLOBAL';</code></pre>
<h5 id="立即执行函数">立即执行函数</h5>
<ol>
<li></li>
</ol>
<pre class="language-none"><code class="language-none">//立即执行函数的两种写法

//第一种：用括号把整个函数定义和调用包裹起来
(function(){
 //function body
}())

//第二种：用括号把函数定义包裹起来，后面再加括号
(function (){
 //function body
})()</code></pre>
<p>2.<strong>立即执行函数</strong>原理</p>
<p><img src="https://xin--images.oss-cn-hongkong.aliyuncs.com/images1/202202250041598.png" alt="image-20220225004131435"></p>
<p>立即执行函数一般也写成匿名函数，匿名函数写法为function(){/…/}，所谓匿名函数，就是使用function关键字声明一个函数，但未给函数命名，倘若需要传值，直接将参数写到括号内即可。</p>
<p>将它赋予一个变量则创建函数表达式，赋予一个事件则成为事件处理程序等。但是需要注意的是匿名函数不能单独使用，否则会js语法报错，至少要用()包裹起来。</p>
<p>了解了立即函数的原理，就可以再扩展出其他的写法：</p>
<pre class="language-none"><code class="language-none">(function foo(){console.log("Hello World!")}())//用括号把整个表达式包起来,正常执行
(function foo(){console.log("Hello World!")})()//用括号把函数包起来，正常执行
!function foo(){console.log("Hello World!")}()//使用！，求反，这里只想通过语法检查。
+function foo(){console.log("Hello World!")}()//使用+，正常执行
-function foo(){console.log("Hello World!")}()//使用-，正常执行
~function foo(){console.log("Hello World!")}()//使用~，正常执行
void function foo(){console.log("Hello World!")}()//使用void，正常执行
new function foo(){console.log("Hello World!")}()//使用new，正常执行
</code></pre>
<p>3.立即执行函数的作用</p>
<blockquote>
<p>【一句话总结】立即执行函数会形成一个单独的作用域，我们可以封装一些临时变量或者局部变量，避免污染全局变量。</p>
</blockquote>
<p>4.与立即执行函数相关的面试题：</p>
<pre class="language-none"><code class="language-none">&lt;body&gt;
    &lt;ul id="list"&gt;
        &lt;li&gt;公司简介&lt;/li&gt;
        &lt;li&gt;联系我们&lt;/li&gt;
        &lt;li&gt;营销网络&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
       var list = document.getElementById("list");
      var li = list.children;
      for(var i = 0 ;i&lt;li.length;i++){
        li[i].onclick=function(){
          alert(i);  // 结果总是3.而不是0，1，2
        }
      }
     &lt;/script&gt;  
&lt;/body&gt;
为什么alert总是3? 因为i是贯穿整个作用域的，而不是给每一个li分配一个i,点击事件使异步，用户一定是在for运行完了以后，才点击，此时i已经变成3了。
那么怎么解决这个问题呢，可以用立即执行函数，给每个li创建一个独立的作用域,在立即执行函数执行的时候，i的值从0到2，对应三个立即执行函数，这3个立即执行函数里边的j分别是0，1，2所以就能正常输出了，看下边例子：
&lt;body&gt;
    &lt;ul id="list"&gt;
        &lt;li&gt;公司简介&lt;/li&gt;
        &lt;li&gt;联系我们&lt;/li&gt;
        &lt;li&gt;营销网络&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
       var list = document.getElementById("list");
      var li = list.children;
      for(var i = 0 ;i&lt;li.length;i++){
       ( function(j){
            li[j].onclick = function(){
              alert(j);
          })(i); 把实参i赋值给形参j
        }
      }
     &lt;/script&gt;  
&lt;/body&gt;
也可以使用ES6的块级作用域解决整个问题
&lt;body&gt;
    &lt;ul id="list"&gt;
        &lt;li&gt;公司简介&lt;/li&gt;
        &lt;li&gt;联系我们&lt;/li&gt;
        &lt;li&gt;营销网络&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
       var list = document.getElementById("list");
      var li = list.children;
      for(let i = 0 ;i&lt;li.length;i++){
        li[i].onclick=function(){
          alert(i);  // 结果是0，1，2
        }
      }
     &lt;/script&gt;  
&lt;/body&gt;
</code></pre>
<p>5、立即执行函数使用的场景<br>
1、你的代码在页面加载完成之后，不得不执行一些设置工作，比如时间处理器，创建对象等等。<br>
2、所有的这些工作只需要执行一次，比如只需要显示一个时间。<br>
3、但是这些代码也需要一些临时的变量，但是初始化过程结束之后，就再也不会被用到，如果将这些变量作为全局变量，不是一个好的注意，我们可以用立即执行函数——去将我们所有的代码包裹在它的局部作用域中，不会让任何变量泄露成全局变量，看如下代码：<br>
<img src="https://xin--images.oss-cn-hongkong.aliyuncs.com/images1/202202250047304.png" alt="image-20220225004702922"></p>
<p>比如上面的代码，如果没有被包裹在立即执行函数中，那么临时变量todaydom,days,today,year,month,date,day,msg都将成为全局变量（初始化代码遗留的产物）。用立即执行函数之后，这些变量都不会在全局变量中存在，以后也不会其他地方使用，有效的避免了污染全局变量。</p>
<p>6、立即执行函数的参数</p>
<pre class="language-none"><code class="language-none">(function(j){
//代码中可以使用j
})(i)
</code></pre>
<p>如果立即执行函数中需要全局变量，全局变量会被作为一个参数传递给立即执行函数（上例中的i就是一个全局变量，i代表的是实参，j是i在立即执行函数中的形参）。</p>
<p>7、立即执行函数的返回值<br>
像其他函数一样，立即执行函数也可以有返回值。除了可以返回基本类型值以外，立即执行函数也能返回任何类型的值，比如对象，函数。<br>
<img src="https://xin--images.oss-cn-hongkong.aliyuncs.com/images1/202202250048024.png" alt="image-20220225004808915"></p>
<p>上例中立即执行函数的返回值被赋值给了一个变量result，这个函数简单的返回了res的值，这个值事先被计算并被存储在立即执行行数的闭包中。<br>
在五中，如果在以后的代码中我需要msg这个值，我也可以返回一个包含msg的对象，方便在以后代码中使用（这样五中的一些临时变量也没有暴露在外面）。</p>
<p>8、总结立即执行函数有哪些作用？<br>
1、改变变量的作用域（创建一个独立的作用域）上面试题例子<br>
改变变量i的作用域，把全局变量i以参数的形式传递到立即执行函数中，在立即执行函数中定义变量i的形参变量j，变量j就是在立即执行函数的作用域中。（给每个li创建了一个作用域块，点击的时候寻找自由变量j，在立即执行块中找到）</p>
<p>2、封装临时变量</p>
<p>在7小点的代码中，可以封装临时变量，避免全局变量的污染。也可以返回一个在全局中需要的变量（用return）。</p>
<h4 id="Promise">Promise</h4>
<p><img src="https://xin--images.oss-cn-hongkong.aliyuncs.com/images1/image-20220223115123511.png" alt="image-20220223115123511"></p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 面试题：异步同步执行</span>
    <span class="token comment">//1 标杆 =&gt; 构造函数同步执行</span>
    <span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token comment">// .then() 异步执行</span>
    promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
<span class="token comment">// 1243</span>
<span class="token comment">// Promise 新建后立即执行，所以首先输出的是1，2。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。</span>


    <span class="token comment">//2 构造函数 执行一次</span>
    <span class="token comment">// then可以多次调用</span>
    <span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'once'</span><span class="token punctuation">)</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'success'</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token comment">// 'once' 'success' 'success'</span></code></pre>
<p>.prototype…prototype.then()	—如果只有一个函数则表示只有成功回调才会执行then中的方法</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 如果只有一个函数则表示只有成功回调才会执行then中的方法</span>
<span class="token comment">// then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</span>
promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// success</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// failure</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 采用链式的then</span>
<span class="token function">getJSON</span><span class="token punctuation">(</span><span class="token string">"/post/1.json"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
  <span class="token parameter">post</span> <span class="token operator">=&gt;</span> <span class="token function">getJSON</span><span class="token punctuation">(</span>post<span class="token punctuation">.</span>commentURL<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
  <span class="token parameter">comments</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"resolved: "</span><span class="token punctuation">,</span> comments<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token parameter">err</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"rejected: "</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 一个then方法指定的回调函数，返回的是另一个Promise对象。</span>
<span class="token comment">// 第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。</span>
<span class="token comment">// 如果变为resolved，就调用funcA，如果状态变为rejected，就调用funcB。</span></code></pre>
<p>.prototype.catch()</p>
<p><code>Promise.prototype.catch</code>方法是<code>.then(null, rejection)</code>的别名，用于指定发生错误时的回调函数。</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'ok'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
promise
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ok</span>
<span class="token comment">// 上面代码中，Promise 在resolve语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。</span></code></pre>
<p>.prototype.finally()	—<code>finally</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。<code>finally</code>本质上是<code>then</code>方法的特例。</p>
<p>all()	—<code>Promise.all</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<p>​			— 只有p1、p2、p3的状态都变成fulfilled，有一个被rejected，p的状态就变成rejected</p>
<p>​			— 如果作为参数的 Promise 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。（该实例执行完<code>catch</code>(更像是捕获了这个rejected)方法后，也会变成<code>resolved</code>）</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// p的状态由p1、p2、p3决定，分成两种情况。</span>
<span class="token comment">//（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</span>
<span class="token comment">// （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</span>
<span class="token comment">// 下面是一个具体的例子。</span>
<span class="token comment">// 生成一个Promise对象的数组</span>
<span class="token keyword">const</span> promises <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">getJSON</span><span class="token punctuation">(</span><span class="token string">'/post/'</span> <span class="token operator">+</span> id <span class="token operator">+</span> <span class="token string">".json"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span>promises<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">posts</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">reason</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。</span>
<span class="token keyword">const</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=&gt;</span> result<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">e</span> <span class="token operator">=&gt;</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'报错了'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=&gt;</span> result<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">e</span> <span class="token operator">=&gt;</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>

Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">e</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ["hello", Error: 报错了]</span>
上面代码中，p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。该实例执行完catch方法后，也会变成resolved，导致Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。

<span class="token comment">// 如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。</span>
<span class="token keyword">const</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=&gt;</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'报错了'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=&gt;</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>

Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">e</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Error: 报错了</span>
</code></pre>
<p>Promise.any() ：任意一个 promise 被 resolve ，就会立即被 resolve ，并且 resolve 的是第一个正确结果，只有所有的 promise 都 reject 时才会 reject 所有的失败信息</p>
<p>race()	—将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<p>​			—只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p>
<pre class="language-none"><code class="language-none">// 如果指定时间内没有获得结果，就将 Promise 的状态变为reject，否则变为resolve。
const p = Promise.race([
  fetch('/resource-that-may-take-a-while'),
  new Promise(function (resolve, reject) {
    setTimeout(() =&gt; reject(new Error('request timeout')), 5000)
  })
]);

p
.then(console.log)
.catch(console.error);
// 上面代码中，如果 5 秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。</code></pre>
<p>.resolve()	—将现有对象转为 Promise 对象</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span>
<span class="token comment">// 等价于</span>
<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
（<span class="token number">1</span>）参数是一个 Promise 实例

如果参数是 Promise 实例，那么Promise<span class="token punctuation">.</span>resolve将不做任何修改、原封不动地返回这个实例。

（<span class="token number">2</span>）参数是一个thenable对象

thenable对象指的是具有then方法的对象，比如下面这个对象。
<span class="token keyword">let</span> thenable <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">then</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Promise<span class="token punctuation">.</span>resolve方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。
<span class="token keyword">let</span> thenable <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">then</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> p1 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>thenable<span class="token punctuation">)</span><span class="token punctuation">;</span>
p1<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 42</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
上面代码中，thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出 <span class="token number">42</span>。

（<span class="token number">3</span>）参数不是具有then方法的对象，或根本就不是对象

如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise<span class="token punctuation">.</span>resolve方法返回一个新的 Promise 对象，状态为resolved。
<span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'Hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">s</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Hello</span>
上面代码生成一个新的 Promise 对象的实例p。由于字符串Hello不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是resolved，所以回调函数会立即执行。Promise<span class="token punctuation">.</span>resolve方法的参数，会同时传给回调函数。

（<span class="token number">4</span>）不带有任何参数

Promise<span class="token punctuation">.</span>resolve方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。

所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用Promise<span class="token punctuation">.</span>resolve方法。
<span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
需要注意的是，立即resolve的 Promise 对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'three'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'two'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'one'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// one</span>
<span class="token comment">// two</span>
<span class="token comment">// three</span>
<span class="token function">上面代码中，setTimeout</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>在下一轮“事件循环”开始时执行，Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>在本轮“事件循环”结束时执行，console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'one'</span><span class="token punctuation">)</span>则是立即执行，因此最先输出。</code></pre>
<p>reject()	—返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p>
<pre class="language-none"><code class="language-none">const p = Promise.reject('出错了');
// 等同于
const p = new Promise((resolve, reject) =&gt; reject('出错了'))

p.then(null, function (s) {
  console.log(s)
});
// 出错了
上面代码生成一个 Promise 对象的实例p，状态为rejected，回调函数会立即执行。

注意，Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致。

const thenable = {
  then(resolve, reject) {
    reject('出错了');
  }
};

Promise.reject(thenable)
.catch(e =&gt; {
  console.log(e === thenable)
})
// true
上面代码中，Promise.reject方法的参数是一个thenable对象，执行以后，后面catch方法的参数不是reject抛出的“出错了”这个字符串，而是thenable对象。</code></pre>
<p>try()</p>
<p>那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有两种写法。第一种写法是用<code>async</code>函数来写。</p>
<pre class="language-none"><code class="language-none">(async () =&gt; f())()
.then(...)
.catch(...)</code></pre>
<p>第二种写法是使用<code>new Promise()</code>。。。</p>
<pre class="language-none"><code class="language-none">const f = () =&gt; console.log('now');
(
  () =&gt; new Promise(
    resolve =&gt; resolve(f())
  )
)();
console.log('next');
// now
// next
</code></pre>
<p>事实上，<code>Promise.try</code>就是模拟<code>try</code>代码块，就像<code>promise.catch</code>模拟的是<code>catch</code>代码块。</p>
<h4 id="手写Promise">手写Promise</h4>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 简单版本</span>




<span class="token comment">// 链式调用版</span></code></pre>
<h4 id="fetch和ajax的区别">fetch和ajax的区别</h4>
<p>fetch是xhr的替代品。<br>
ajax利用XMLHttpRequest对象来请求数据。</p>
<h5 id="原生的ajax">原生的ajax</h5>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">&gt;=</span> <span class="token number">200</span> <span class="token operator">&amp;&amp;</span> xhr<span class="token punctuation">.</span>status <span class="token operator">&lt;</span> <span class="token number">300</span> <span class="token operator">||</span> xhr<span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">304</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'error:::'</span><span class="token punctuation">,</span> xhr<span class="token punctuation">.</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token string">"demo.txt"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">"MyHeader"</span><span class="token punctuation">,</span> <span class="token string">"MyValue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
注意点：

<span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法接收一个参数，作为请求主体发送的数据。如果不需要发送数据最好传入<span class="token keyword">null</span>，因为参数对有些浏览器来说是必须的
<span class="token function">必须在调用open</span><span class="token punctuation">(</span><span class="token punctuation">)</span>之前指定onreadystatechange事件处理程序才能确保跨浏览器 兼容性
<span class="token function">要成功发送请求头部信息，必须在调用open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">方法之后且调用send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">方法之前调用setRequestHeader</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p>fetch 是全局量 window 的一个方法。特点：</p>
<p>fetch是基于promise实现的，也可以结合async/await。<br>
fetch请求默认是不带cookie的，需要设置fetch（URL，{credentials:’include’})<br>
Credentials的三种参数：omit（从不发送cookie），same-origin（同源发送），include（始终发送）<br>
服务器返回400、500 状态码时并不会reject，只有网络出错导致请求不能完成时，fetch才会被reject<br>
所有版本的 IE 均不支持原生 Fetch</p>
<h4 id="跨域问题">跨域问题</h4>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">由于浏览器的同源策略会导致跨域，同源策略又分为

一：<span class="token constant">DOM</span>同源策略：禁止对不同源页面的<span class="token constant">DOM</span>进行操作，主要是不同域名的ifram是限制互相访问的
二：xmlHttpRequest同源策略：禁止使用<span class="token constant">XHR</span>对象向不同源的服务器地址发起http请求，只要域名  协议  端口有一个不同都被当做不同的域之间的请求，即跨域请求

解决方式：
<span class="token number">1</span>、<span class="token constant">CORS</span>跨域资源共享   后端需要设置Access<span class="token operator">--</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Origin<span class="token operator">:</span><span class="token boolean">true</span>
<span class="token number">2</span>、<span class="token constant">JSONP</span>。利用<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>标签不发生跨域的特点，在服务器链接的参数中加入callback回调函数，通过这个回调函数获取服务端要传来的值。只能用于<span class="token constant">GET</span>请求。
<span class="token number">3</span>、 nginx代理跨域，设置代理服务器转发。这种方式实际上还是同源。因为服务器之间的通信不存在跨域的问题，所以可以设置一个与客户端同源的代理服务器作为中间人。（代理是设置哪一项）
<span class="token number">4</span>、nodejs中间件代理跨域
<span class="token number">5</span>、WebSokect协跨域
<span class="token number">6</span>、window<span class="token punctuation">.</span>name<span class="token operator">+</span>ifram跨域</code></pre>
<h4 id="jsonp原理">jsonp原理</h4>
<p><strong>jsonp</strong>的核心则是动态添加<script>标签来调用<strong>服务器</strong>提供的<strong>js脚本</strong>。只支持GET方法</p>
<p>通过动态添加script标签，利用其中的src属性并不被同源策略所约束，向src属性中添加查询参数和callback回调函数作为参数，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据进行传递，实现服务器端向客户端通信。</p>
<h4 id="this指向问题">this指向问题</h4>
<h5 id="this-永远指向最后调用它的那个对象"><strong>this 永远指向最后调用它的那个对象</strong></h5>
<p>手写this指向的区别</p>
<pre class="language-none"><code class="language-none">console.log(this) &#x2F;&#x2F; window
function a() &#123;
    console.log(this)
&#125;
a()&#x2F;&#x2F; window

let b &#x3D; 1
let o &#x3D; &#123;
    b:2,
    fn1: function() &#123;
        console.log(this.b) &#x2F;&#x2F; 2
    &#125;,
    c:&#123;
        b:3,
        fn2:function() &#123;
            console.log(this.b) &#x2F;&#x2F; 3
        &#125;
    &#125;
&#125;
o.fn1()
o.c.fn2()


&#x2F;&#x2F; let id &#x3D; 66 &#x2F;&#x2F; 不会挂到window
&#x2F;&#x2F; var定义的变量会直接挂载到window上
var id &#x3D; 66;
function fn5()&#123;
    &#x2F;&#x2F; 1. 箭头函数没有作用域 &#x3D;&gt; 没有this
    setTimeout(() &#x3D;&gt; &#123;
        console.log(this.id) &#x2F;&#x2F; window
    &#125;, 500)
&#125;

&#x2F;&#x2F; fn5(&#123;id: 21&#125;)

fn5.call(&#123;id: 21&#125;)

&#x2F;&#x2F; call, apply, bind
&#x2F;&#x2F; call, apply 传参的不同 改变 + 执行
&#x2F;&#x2F; bind() 只改变this的指向，不会执行</code></pre>
<h5 id="怎么改变-this-的指向">怎么改变 this 的指向</h5>
<ul>
<li>使用 ES6 的箭头函数</li>
<li>在函数内部使用 <code>_this = this</code></li>
<li>使用 <code>apply</code>、<code>call</code>、<code>bind</code></li>
<li>new 实例化一个对象</li>
</ul>
<h5 id="箭头函数的this">箭头函数的this</h5>
<p>箭头函数的this会继承父执行上下文里面的this</p>
<p>如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined”。</p>
<h5 id="this-this">_this = this</h5>
<p>先将调用这个函数的对象保存在变量 <code>_this</code> 中，然后在函数中都使用这个 <code>_this</code>，这样 <code>_this</code> 就不会改变了。</p>
<h4 id="setTimeout的this">setTimeout的this</h4>
<p>在setInterval和setTimeout中传入函数时，函数中的this会指向window对象，这是由于setTimeout或者setInterval调用的代码，是运行在与其所在函数完全分离的执行环境上。 这就会导致这些代码中包含的 this 关键字会指向 window (或全局)对象，但是在setTimeout或者setInterval中传入的不是函数时，this则指向当前对象</p>
<h5 id="bind、call和apply">bind、call和apply</h5>
<p>相同点：都可以改变this指向</p>
<p>区别：</p>
<p>bind不调用函数，返回一个新的函数，只有一个参数，指明this的指向<br>
call会直接调用函数，call只有一个参数，指明this的指向<br>
apply有两个参数，第二个参数一般为数组，apply将数组展开传给函数</p>
<h4 id="Object">Object</h4>
<h5 id="hasOwnProperty方法">hasOwnProperty方法</h5>
<p>hasOwnProperty() 方法会返回一个<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%B8%83%E5%B0%94&amp;spm=1001.2101.3001.7020">布尔</a>值，指示对象自身属性中（非继承属性）是否具有指定的属性，</p>
<p>无法通过obj.hasOwnProperty(prop)判断继承属性</p>
<pre class="language-none"><code class="language-none">obj&#x3D; new Object();
obj.name &#x3D; &#39;刘家军&#39;;
const a &#x3D; obj.hasOwnProperty(&#39;name&#39;);
console.log(a); &#x2F;&#x2F; true
const b &#x3D; obj.hasOwnProperty(&#39;toString&#39;);
console.log(b); &#x2F;&#x2F; false
const c &#x3D; obj.hasOwnProperty(&#39;hasOwnProperty&#39;);
console.log(c); &#x2F;&#x2F; false</code></pre>
<p>如果要判断继承属性，通过<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8E%9F%E5%9E%8B%E9%93%BE&amp;spm=1001.2101.3001.7020">原型链</a>prototype判断</p>
<pre class="language-none"><code class="language-none">const d &#x3D; Object.prototype.hasOwnProperty(&#39;toString&#39;)
console.log(d); &#x2F;&#x2F; true
const e &#x3D; String.prototype.hasOwnProperty(&#39;split&#39;)
console.log(e); &#x2F;&#x2F; true
</code></pre>
<h4 id="原型与原型链">原型与原型链</h4>
<h5 id="prototype和-proto-的关系">prototype和__proto__的关系</h5>
<p>所有的对象都拥有_ proto _属性，它指向构造函数的prototype原型对象，最后指向Object.prototype(Object是一个原生函数，所有的对象都是Object的实例)。</p>
<p>所有的函数都同时拥有_ proto <em>和prototype属性，</em></p>
<p><em>函数的</em> _ proto _指向自己的函数实现，</p>
<p>函数的prototype是一个对象，所以函数的prototype也有_ proto _属性，指向Object.prototype。</p>
<p>Object.prototype._ proto _指向null（原型链的终点指向null）。</p>
<h5 id="构造函数、原型、实例的关系">构造函数、原型、实例的关系</h5>
<pre class="language-none"><code class="language-none">构造函数中有一个prototype指针指向原型，
原型中也有一个constructor指针指向构造函数。
实例中有一个内部属性__proto__指向原型。
查找方式是一层一层查找，直至顶层。Object.prototype</code></pre>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 先创建一个person1的空对象，然后把person1通过__proto__指向原型对象，指向构造函数中的代码，person1就获得了一个叫做name的属性，</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>     <span class="token comment">// 1</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">welcome</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token comment">// 5</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>welcome<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Smiley'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 9</span>
person1<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token string">'Hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span>
<span class="token comment">// 每一个javascript对象(除null外)创建的时候，就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型中“继承”属性。</span>

<span class="token comment">// 从当前实例属性去查找，如果找了就返回，否则顺着原型链一层一层往上面找</span>
<span class="token comment">// 直到找到null为止，如果找到null都没有找到，报错，属性报undefine，方法报错</span>

<span class="token keyword">var</span> <span class="token function-variable function">A</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token class-name">A</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">A</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  n<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  m<span class="token operator">:</span> <span class="token number">3</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 1、undefined、2、3</span>


<span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'a'</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'green'</span><span class="token punctuation">,</span> <span class="token string">'yellow'</span><span class="token punctuation">]</span>
 <span class="token punctuation">&#125;</span>
 <span class="token keyword">function</span> <span class="token constant">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
 <span class="token class-name">B</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token keyword">var</span> b1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token keyword">var</span> b2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token comment">// 放在自己的私有属性了</span>
 b1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'change'</span>
 b1<span class="token punctuation">.</span>color<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'black'</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b2<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// 'a'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b2<span class="token punctuation">.</span>color<span class="token punctuation">)</span> <span class="token comment">// ["green", "yellow", "black"]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b1<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// 'change' </span></code></pre>
<p><img src="https://pic4.zhimg.com/80/v2-109c6159bd3523658b1f5bfc48acc47f_720w.jpg" alt="img"></p>
<p>一个新的对象有私有的属性，也有原型的属性</p>
<h5 id="使用new这个关键字的时候，JS编译器会做四件事情">使用new这个关键字的时候，JS编译器会做四件事情</h5>
<ol>
<li>创建一个新的空的对象</li>
<li>把这个对象链接到原型对象上，将构造函数的作用域赋给新对象（因此this就指向了这个新对象）</li>
<li>执行构造函数中的代码（为这个新对象添加属性）</li>
<li>如果这个函数有返回值，则返回；否则，就会默认返回新对象</li>
</ol>
<p>常规函数默认返回undefined，构造函数默认返回</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">/**
 * new的过程文字描述：
1.创建一个空对象 obj;
2.将空对象的隐式原型（proto）指向构造函数的prototype。
3.使用 call 改变 this 的指向
4.如果无返回值或者返回一个非对象值，则将 obj 返回作为新对象；如果返回值是一个新对象的话那么直接直接返回该对象。
new 关键词执行之后总是会返回一个对象，要么是实例对象，要么是 return 语句指定的对象。 
*/</span>

<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
<span class="token punctuation">&#125;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayHi</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hi！我是'</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">function</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 创建空对象</span>
  <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
  <span class="token comment">// 隐式原型</span>
  <span class="token comment">// 处理参数列表。参数列表包含了类和构造函数的参数</span>
  <span class="token keyword">const</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span>
  <span class="token keyword">let</span> fn <span class="token operator">=</span> args<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">// 将空对象的隐式原型（proto）指向构造函数的prototype。</span>
  obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> fn<span class="token punctuation">.</span>prototype
  <span class="token comment">// 通过call改变this的指向</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
  <span class="token comment">// 返回</span>
  <span class="token keyword">return</span> <span class="token keyword">typeof</span> result <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">?</span> result <span class="token operator">:</span> obj
<span class="token punctuation">&#125;</span>
<span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token function">create</span><span class="token punctuation">(</span>Person<span class="token punctuation">,</span> <span class="token string">'李四'</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span>
p2<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<h4 id="闭包">闭包</h4>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 1. 闭包是什么？—— 方法里返回一个方法</span>
        <span class="token comment">// function a()&#123;</span>
        <span class="token comment">//     let a1 = 1;</span>
        <span class="token comment">//     return function()&#123;</span>
        <span class="token comment">//         return a1</span>
        <span class="token comment">//     &#125;</span>
        <span class="token comment">// &#125;</span>
        <span class="token comment">// 2. 闭包存在的意义？</span>
        <span class="token comment">// 2.1 延长变量的生命周期  </span>
        <span class="token comment">// 2.2 创建私有环境</span>

		<span class="token comment">// 为什么</span>
        <span class="token comment">// 会生成一份临时的变量对象AO，存方法和局部变量，方法执行完b就回收了</span>
        let a <span class="token operator">=</span> <span class="token string">'小明'</span>
        function <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            let b <span class="token operator">=</span> <span class="token number">1</span>
            <span class="token comment">// console.log(a)</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">// console.log(b)</span>

<span class="token comment">// 作用域链：就近原则</span>
        <span class="token comment">// let name = "小明"</span>
        <span class="token comment">// function fn2()&#123;</span>
        <span class="token comment">//     // let name = "小白"</span>
        <span class="token comment">//     function fn3()&#123;</span>
        <span class="token comment">//         // let name = "小红"</span>
        <span class="token comment">//         console.log(name)</span>
        <span class="token comment">//     &#125;</span>
        <span class="token comment">//     fn3()</span>
        <span class="token comment">// &#125;</span>
        <span class="token comment">// fn2()</span>
<span class="token comment">// 全局对象可能会污染其他的局部变量，不会被垃圾回收机制回收</span>
<span class="token comment">// 闭包会常驻内存 => 慎用闭包</span></code></pre>
<p>key值得作用是什么？可以用数组的下表代替吗？</p>
<p>提供给dom唯一的值（让虚拟dom高效更新），不建议（1，多个数组，2，数组的增删的操作）</p>
<h5 id="data-为甚是一个函数？">data()为甚是一个函数？</h5>
<p>​     // 闭包 =&gt; 每一个组件都有自己的私有作用域，确保各组件数据不会相互干扰</p>
<p>​     // 纯对象 =&gt; 干扰 let obj = {}</p>
<h4 id="防抖节流">防抖节流</h4>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token constant">DOCTYPE</span> html<span class="token operator">></span>
<span class="token operator">&lt;</span>html lang<span class="token operator">=</span><span class="token string">"en"</span><span class="token operator">></span>
<span class="token operator">&lt;</span>head<span class="token operator">></span>
    <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>meta http<span class="token operator">-</span>equiv<span class="token operator">=</span><span class="token string">"X-UA-Compatible"</span> content<span class="token operator">=</span><span class="token string">"IE=edge"</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>meta name<span class="token operator">=</span><span class="token string">"viewport"</span> content<span class="token operator">=</span><span class="token string">"width=device-width, initial-scale=1.0"</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>style<span class="token operator">></span>
        <span class="token punctuation">.</span>box<span class="token punctuation">&#123;</span>
            background<span class="token operator">-</span>color<span class="token operator">:</span> green<span class="token punctuation">;</span>
            width<span class="token operator">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>
            height<span class="token operator">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>style<span class="token operator">></span>
    <span class="token operator">&lt;</span>title<span class="token operator">></span>Document<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span>
<span class="token operator">&lt;</span>body<span class="token operator">></span>
    <span class="token operator">&lt;</span>h2<span class="token operator">></span>深入js防抖与节流<span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">></span>
    <span class="token operator">&lt;</span>input placeholder<span class="token operator">=</span><span class="token string">"请输入电话"</span> <span class="token operator">/</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"box"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
    <span class="token operator">&lt;</span>script<span class="token operator">></span>
        <span class="token comment">// 防抖 =>固定的时间内， 事件只允许发生一次</span>
        <span class="token keyword">let</span> telInput <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'input'</span><span class="token punctuation">)</span>
        telInput<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'input'</span><span class="token punctuation">,</span> <span class="token function">antiShake</span><span class="token punctuation">(</span>demo<span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

        <span class="token comment">// 防抖封装</span>
        <span class="token keyword">function</span> <span class="token function">antiShake</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> wait</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">let</span> timeOut <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">let</span> contex <span class="token operator">=</span> <span class="token keyword">this</span>
                <span class="token keyword">let</span> args <span class="token operator">=</span> arguments
                <span class="token keyword">if</span><span class="token punctuation">(</span>timeOut<span class="token punctuation">)</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeOut<span class="token punctuation">)</span>
                timeOut <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>
                    <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>contex<span class="token punctuation">,</span>args<span class="token punctuation">)</span>
                <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">function</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'发起请求'</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// 节流 => 一定时间内的多个事情合为一个</span>
        <span class="token comment">// 应用场景 => 1. 提交表单  2. 高频监听事件</span>
        <span class="token keyword">let</span> box <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">".box"</span><span class="token punctuation">)</span>
        box<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"touchmove"</span><span class="token punctuation">,</span> <span class="token function">throttle</span><span class="token punctuation">(</span>demo<span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

        <span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> time</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span>
            <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">let</span> contex <span class="token operator">=</span> <span class="token keyword">this</span>
                <span class="token keyword">let</span> args <span class="token operator">=</span> arguments
                <span class="token keyword">if</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
                timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
                    <span class="token function">func</span><span class="token punctuation">(</span>contex<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// 通过时间戳</span>


    <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span>
</code></pre>
<h4 id="内存泄漏及导致的原因及解决办法">内存泄漏及导致的原因及解决办法</h4>
<p>不再用到的内存，没有及时释放，就叫做内存泄漏。</p>
<p>常见的导致内存泄露的原因有： 1；意外的全局变量 2；被遗忘的计时器或回调函数 3；脱离文档的DOM的引用 4；闭包</p>
<h5 id="解决办法">解决办法</h5>
<p>有addListener就得有removeListener。在mounted的时候注册的监听，在beforeDestroy时候销毁。</p>
<h4 id="垃圾回收机制">垃圾回收机制</h4>
<p>标记清除</p>
<p>垃圾回收机制在运行的时候会给存储在内存中的所有变量都加上标记(可以是任何标记方式)，然后，它会去掉处在环境中的变量 及被环境中的变量引用的变量标记(闭包)。而在此之后剩下的带有标记的变量被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后垃圾回收机制到下一个周期运行时，将释放这些变量的内存，回收它们所占用的空间。</p>
<p>引用计数</p>
<p>记录每个对象被引用的次数，每次新建对象、赋值引用和删除引用的同时更新计数器，如果计数器值为0则直接回收内存。</p>
<p>引用计数（reference counting）。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。</p>
<p>引用计数策略有一个很严重的问题：<strong>循环引用。</strong><br>
如果对象 A 中包含一个指针指向对象 B，而对象 B 中也包含一个指针指向对象 A。那么这两个对象引用次数都是 2，但实际上已经可以回收了。若这种函数被反复多次调用，会导致大量内存得不到回收。</p>
<h4 id="堆内存和栈内存">堆内存和栈内存</h4>
<p>栈内存：存放基本数据类型String、Number、undefined、Boolean、null</p>
<p>堆内存：存放引用类型Object、Array、Function、Date、RegExp、包装类型（Boolean、Number、String）</p>
<h4 id="什么是事件委托（事件代理），事件委托有哪些优点？">什么是事件委托（事件代理），事件委托有哪些优点？</h4>
<p>事件委托就是将事件绑定到父元素上，根据事件的冒泡，当子元素处理事件时会自动触发父元素的事件。通过判断事件对象event的target可以找到时间实际发生的子元素。</p>
<p>优点：提高性能、动态监听。提高性能是因为减少了事件监听的数量，动态监听是指当增加一个子元素时，该子元素自动拥有父级元素上绑定的事件。</p>
<p>举例：最经典的就是ul和li标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在li标签上直接添加，而是在ul父元素上添加。</p>
<h4 id="作用域、作用域链">作用域、作用域链</h4>
<p>js没有块作用域，只有函数作用域。函数内部的函数可以访问到外函数中的变量，他们都可以访问到全局作用域中的变量，全局执行环境的变量对象始终是作用域链中的最后一个对象。</p>
<p>es6中的let、const可以达到块级作用域的效果。、</p>
<h4 id="冒泡和捕获">冒泡和捕获</h4>
<p>冒泡是从内向外，捕获是从外向内。<br>
冒泡一般会在讲事件委托的时候提到。</p>
<h4 id="模块化">模块化</h4>
<h5 id="CommonJs">CommonJs</h5>
<p>用于后端node和前端webpack</p>
<p>接口：module.exports和require</p>
<p>特点：</p>
<p>模块输出的是一个值的拷贝，模块是运行时加载，同步加载<br>
CommonJS 模块的顶层this指向当前模块<br>
AMD（Asynchronous Module Definition，异步模块定义）<br>
浏览器端模块化开发的规范，require.js为AMD规范的实现<br>
接口：define、require、config<br>
特点：异步加载，不阻塞页面的加载，能并行加载多个模块，但是不能按需加载，必须提前加载所需依赖</p>
<h5 id="ES6-module">ES6 module</h5>
<p>接口：import、export、export default<br>
内嵌在网页中的用法：</p>
<pre class="language-none"><code class="language-none">&lt;script type&#x3D;&quot;module&quot;&gt;
  import utils from &quot;.&#x2F;utils.js&quot;;
  &#x2F;&#x2F; other code
&lt;&#x2F;script&gt;</code></pre>
<p>此时不能用file协议，否则会报跨域的错误<br>
特点：</p>
<p>ES6 模块之中，顶层的this指向undefined，即不应该在顶层代码使用this<br>
自动采用严格模式&quot;use strict&quot;。须遵循严格模式的要求<br>
ES6 模块的设计思想是尽量的静态化，编译时加载”或者静态加载，编译时输出接口<br>
ES6 模块export、import命令可以出现在模块的任何位置，但是必须处于模块顶层。如果处于块级作用域内，就会报错<br>
ES6模块输出的是值的引用</p>
<p>Tree-Shaking<br>
介绍：消除无用的代码，减少js包的大小，从而减少页面的加载时间。</p>
<p>原理：找到有用的代码打包进去。依赖es6的module模块，tree shaking会分析文件项目里具体哪些代码被引入了，哪些没有引入，然后将真正引入的代码打包进去，最后没有使用到的代码自然就不会存在了。</p>
<h4 id="require和import的区别">require和import的区别</h4>
<p>require 和 import 分别是不同模块化规范下引入模块的语句</p>
<p>出现的时间、地点不同</p>
<p>不同端(客户端/服务器)的使用限制：CommonJS 模块化方案 require/exports 是为服务器端开发设计的。在浏览器端，因为其<strong>异步加载脚本文件</strong>的特性，CommonJS 规范无法正常加载。</p>
<p>require/exports 是运行时动态加载，import/export 是静态编译</p>
<p>require/exports 输出的是一个值的拷贝，import/export 模块输出的是值的引用</p>
<p>用法不一致：import/export 不能对引入模块重新赋值/定义，ES6 模块可以在 import 引用语句前使用模块，CommonJS 则需要先引用后使用。import/export 只能在模块顶层使用，不能在函数、判断语句等代码块之中引用；require/exports 可以。是否采用严格模式：import/export 导出的模块默认调用严格模式，require/exports 默认不使用严格模式，可以自定义是否使用严格模式。 例如</p>
<h4 id="js的事件执行机制">js的事件执行机制</h4>
<p>Event Loop和宏任务微任务</p>
<pre class="language-none"><code class="language-none">js是一个单线程语言，所以所有的任务只能排队一个一个去做，这样效率明显很低。
所以event loop就是为解决这个问题而提出的。
在主程序中，分为两个线程，一个运行程序本身，称作主线程，另一个负责主线程和其它线程进行通信（主要是I&#x2F;O操作），被称作event loop线程
在运行程序的时候，当遇到I&#x2F;O操作的时候，主线程就让Event loop 线程通知相应的I&#x2F;O模块去执行，然后主线程接着执行之后的代码，等到I&#x2F;O结束后，event loop线程再把运行结果交给主线程，然后主线程再执行相应的回调，整个任务结束。

宏任务 微任务
宏任务（macro-task）：一般是 JS 引擎和宿主环境发生通信产生的回调任务，比如 setTimeout，setInterval 是浏览器进行计时的，其中回调函数的执行时间需要浏览器通知到 JS 引擎，网络模块, I&#x2F;O处理的通信回调也是。包含有 setTimeout，setInterval，DOM事件回调，ajax请求结束后的回调，整体 script 代码，setImmediate。

微任务（micro-task）：一般是宏任务在线程中执行时产生的回调，如 Promise，process.nextTick，Object.observe(已废弃)， MutationObserver（DOM监听），这些都是 JS 引擎自身可以监听到回调。
常见的宏任务有：setTimeout setTimeInterval
常见的微任务有：&quot;MutationObserver、Promise.then(或.reject) 以及以 Promise 为基础开发的其他技术(比如fetch API), 还包括 V8 的垃圾回收过程&quot;
上面我们了解了宏任务与微任务的分类，那么为什么我们要将其分为宏任务与微任务呢？主要是因为其添加到事件循环中的任务队列的机制不同。

在事件循环中，任务一般都是由宏任务开始执行的（JS代码的加载执行），在宏任务的执行过程中，可能会产生新的宏任务和微任务，这时候宏任务（如ajax回调）会被添加到任务队列的末尾等待事件循环机制执行，而微任务则会被添加到当前任务队列的前端，也是等待事件循环机制的执行。

其中相同类型的宏任务或微任务会按照回调的先后顺序进行排序，而不同任务类型的任务会有一定的优先级，按照不同类型任务区分

宏任务优先级，主代码块 &gt; setImmediate &gt; MessageChannel &gt; setTimeout &#x2F; setInterval

微任务优先级，process.nextTick &gt; Promise &gt; MutationObserver
nextTick
process.nextTick 是一个独立于 eventLoop 的任务队列。
在每一个 eventLoop 阶段完成后会去检查这个队列，如果里面有任务，会让这部分任务优先于微任务执行。</code></pre>
<pre class="language-none"><code class="language-none">&#x2F;&#x2F;主线程直接执行
console.log(&#39;1&#39;);
&#x2F;&#x2F;丢到宏事件队列中
setTimeout(function() &#123;
    console.log(&#39;2&#39;);
    process.nextTick(function() &#123;
        console.log(&#39;3&#39;);
    &#125;)
    new Promise(function(resolve) &#123;
        console.log(&#39;4&#39;);
        resolve();
    &#125;).then(function() &#123;
        console.log(&#39;5&#39;)
    &#125;)
&#125;)
&#x2F;&#x2F;微事件1
process.nextTick(function() &#123;
    console.log(&#39;6&#39;);
&#125;)
&#x2F;&#x2F;主线程直接执行
new Promise(function(resolve) &#123;
    console.log(&#39;7&#39;);
    resolve();
&#125;).then(function() &#123;
    &#x2F;&#x2F;微事件2
    console.log(&#39;8&#39;)
&#125;)
&#x2F;&#x2F;丢到宏事件队列中
setTimeout(function() &#123;
    console.log(&#39;9&#39;);
    process.nextTick(function() &#123;
        console.log(&#39;10&#39;);
    &#125;)
    new Promise(function(resolve) &#123;
        console.log(&#39;11&#39;);
        resolve();
    &#125;).then(function() &#123;
        console.log(&#39;12&#39;)
    &#125;)
&#125;)
• 首先浏览器执行js进入第一个宏任务进入主线程, 直接打印console.log(&#39;1&#39;)

• 遇到 setTimeout  分发到宏任务Event Queue中

• 遇到 process.nextTick 丢到微任务Event Queue中

• 遇到 Promise， new Promise 直接执行 输出 console.log(&#39;7&#39;);

• 执行then 被分发到微任务Event Queue中

•第一轮宏任务执行结束，开始执行微任务 打印 6,8

•第一轮微任务执行完毕，执行第二轮宏事件，执行setTimeout

•先执行主线程宏任务，在执行微任务，打印&#39;2,4,3,5&#39;

•在执行第二个setTimeout,同理打印 ‘9,11,10,12’

•整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。

以上是在浏览器环境下执行的数据，只作为宏任务和微任务的分析，我在node环境下测试打印出来的顺序为：1，7，6，8，2，4，9，11，3，10，5，12。node环境执行结果和浏览器执行结果不一致的原因是：浏览器的Event loop是在HTML5中定义的规范，而node中则由libuv库实现。libuv库流程大体分为6个阶段：timers，I&#x2F;O callbacks，idle、prepare，poll，check，close callbacks，和浏览器的microtask，macrotask那一套有区别。</code></pre>
<h3 id="Nodejs">Nodejs</h3>
<h4 id="js的事件执行机制：">js的事件执行机制：</h4>
<h4 id="EventLoop">EventLoop</h4>
<p>在程序中设置两个线程：一个负责程序本身的运行，称为&quot;主线程&quot;；另一个负责主线程与其他进程（主要是各种I/O操作）的通信，被称为&quot;Event Loop线程&quot;（可以译为&quot;消息线程&quot;）。每当遇到I/O的时候，主线程就让Event Loop线程去通知相应的I/O程序，然后接着往后运行，所以不存在等待时间。等到I/O程序完成操作，Event Loop线程再把结果返回主线程。主线程就调用事先设定的回调函数，完成整个任务。由于多出了空闲时间，所以主线程得以运行更多的任务，这就提高了效率。这种运行方式称为&quot;<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Asynchronous_I/O">异步模式</a>&quot;（asynchronous I/O）或&quot;非堵塞模式&quot;（non-blocking mode）。</p>
<h5 id="三大关键阶段">三大关键阶段</h5>
<ol>
<li>timer：执行定时器时，如 setTimeout、setInterval，在 timers 阶段执行</li>
<li>poll：异步操作，比如文件I/O，网络I/O等，通过’data’、 'connect’等事件通知 JS 主线程并执行回调的，此阶段就是 poll 轮询阶段</li>
<li>check：这是一个比较简单的阶段，直接执行 setImmdiate 的回调。</li>
</ol>
<p>注意，若 2 阶段结束后，当前存在到时间的定时器，那么拿出来执行，eventLoop 将再回到 timer 阶段</p>
<h5 id="阶段流程概述">阶段流程概述</h5>
<ul>
<li>timers: 本阶段执行已经安排的 setTimeout() 和 setInterval() 的回调函数</li>
<li>IO / callbacks: 执行 I/O 异常的回调，如TCP 连接遇到 ECONNREFUSED</li>
<li>idle, prepare: 仅系统内部使用，只是表达空闲、预备状态(第2阶段结束，poll 未触发之前)</li>
<li>poll: 检索新的 I/O 事件；执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数），node 将在此处阻塞。</li>
<li>check: setImmediate() 回调函数在这里执行.</li>
<li>close callbacks: 一些准备关闭的回调函数，如：socket.on(‘close’, …)</li>
</ul>
<p>在每次运行的事件循环之间，Node.js 检查它是否在等待任何异步 I/O 或计时器，如果没有的话，则关闭干净。</p>
<h4 id="相关面试题">相关面试题</h4>
<pre class="language-text" data-language="text"><code class="language-text">console.log('start')

setTimeout(() => &#123;
  console.log('setTimeout')
&#125;, 0)

new Promise((resolve) => &#123;
  console.log('promise')
  resolve()
&#125;)
  .then(() => &#123;
    console.log('then1')
  &#125;)
  .then(() => &#123;
    console.log('then2')
  &#125;)

console.log('end')</code></pre>
<p>结果为：</p>
<pre class="language-text" data-language="text"><code class="language-text">start 
promise
end
then1
then2
setTimeout</code></pre>
<pre class="language-none"><code class="language-none">&#x2F;&#x2F; setTimeout1
setTimeout(() &#x3D;&gt; &#123;
  console.log(1)

  new Promise((resolve) &#x3D;&gt; &#123;
    resolve()
  &#x2F;&#x2F; Promise1
  &#125;).then(() &#x3D;&gt; &#123;
    console.log(2)
  &#125;);
&#125;)

&#x2F;&#x2F; setTimeout2
setTimeout(() &#x3D;&gt; &#123;
  console.log(3)
&#125;)

new Promise((resolve) &#x3D;&gt; &#123;
  console.log(4)
  resolve()
  console.log(5)
&#x2F;&#x2F; Promise2
&#125;).then(() &#x3D;&gt; &#123;
  console.log(6)
&#125;)

console.log(7)

new Promise((resolve) &#x3D;&gt; &#123;
  resolve()
&#x2F;&#x2F; Promise3
&#125;).then(() &#x3D;&gt; &#123;
  console.log(8)
&#125;)</code></pre>
<p><img src="https://img2020.cnblogs.com/blog/1027993/202005/1027993-20200517201508564-925237420.png" alt="img"></p>
<p>分析出了任务队列后，我们就可以轻松得到打印顺序了</p>
<p>首先执行宏任务，按照从上至下的执行顺序依次打印 4 5 7</p>
<p>接着按照任务队列的先后顺序执行异步任务，依次打印 6 8 1 2 3</p>
<h4 id="JS为什么要区分微任务和宏任务">JS为什么要区分微任务和宏任务</h4>
<pre class="language-none"><code class="language-none">为了插队。一个Event Loop， Microtask 是在 Macrotask 之后调用，Microtask 会在下一个Event Loop 之前执行调用完，并且其中会将 Microtask 执行当中新注册的 Microtask 一并调用执行完，然后才开始下一次 Event loop，所以如果有新的 Macrotask 就需要一直等待，等到上一个 Event loop 当中 Microtask 被清空为止。由此可见， 我们可以在下一次 Event loop 之前进行插队。如果不区分 Microtask 和 Macrotask，那就无法在下一次 Event loop 之前进行插队，其中新注册的任务得等到下一个 Macrotask 完成之后才能进行，这中间可能你需要的状态就无法在下一个 Macrotask 中得到同步。状态的同步对于视图来说至关重要，这也就牵扯到了为什么 javascript 是单线程的原因所在</code></pre>
<h4 id="js为什么是单线程，有什么好处？">js为什么是单线程，有什么好处？</h4>
<p>js最初被设计用在浏览器中，假如js是多线程的，当第一个线程上的js与第二个线程上的js同时对一个dom进行操作时，这个dom就不知道该执行哪个线程上的指令。</p>
<h3 id="ES6">ES6</h3>
<h4 id="解构">解构</h4>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token constant">DOCTYPE</span> html<span class="token operator">></span>
<span class="token operator">&lt;</span>html lang<span class="token operator">=</span><span class="token string">"en"</span><span class="token operator">></span>
<span class="token operator">&lt;</span>head<span class="token operator">></span>
    <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>meta http<span class="token operator">-</span>equiv<span class="token operator">=</span><span class="token string">"X-UA-Compatible"</span> content<span class="token operator">=</span><span class="token string">"IE=edge"</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>meta name<span class="token operator">=</span><span class="token string">"viewport"</span> content<span class="token operator">=</span><span class="token string">"width=device-width, initial-scale=1.0"</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>title<span class="token operator">></span>Document<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span>
<span class="token operator">&lt;</span>body<span class="token operator">></span>
    <span class="token operator">&lt;</span>h2<span class="token operator">></span><span class="token constant">ES6</span>相关面试题<span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">></span>
    <span class="token operator">&lt;</span>script<span class="token operator">></span>
    <span class="token comment">// 解构相关</span>
    <span class="token comment">// let a = 1;</span>
    <span class="token comment">// let b = 2;</span>
    <span class="token comment">// [a, b] = [b, a]</span>
    <span class="token comment">// console.log(a, b)</span>
    
    <span class="token comment">// let arr = [12, 43, 23, 12, 43, 55]</span>
    <span class="token comment">// let item = [...new Set(arr)]</span>
    <span class="token comment">// console.log(item)</span>

    <span class="token comment">// 标杆 => 构造函数同步执行</span>
    <span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
    <span class="token comment">// .then() 异步执行</span>
    promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>

    <span class="token comment">// 构造函数 执行一次</span>
    <span class="token comment">// then可以多次调用</span>
    <span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'conce'</span><span class="token punctuation">)</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'success'</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
        promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
        promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span></code></pre>
<h4 id="proxy">proxy</h4>
<p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Proxy&amp;spm=1001.2101.3001.7020">Proxy</a> 是 ES6 中新增的功能，可以用来自定义对象中的操作</p>
<p>每次获取proxy，这个proxy就会返回对data的深拷贝，而要对data中的属性进行增删查等操作，也是直接对proxy下手就行。通过对整个对象的代理，就避免了访问之前要明确data中有什么属性的这一个过程。这样就实现了一个解耦合的过程，避免了直接操作data对象。基本的使用示例如下。</p>
<h4 id="箭头函数与普通函数的区别">箭头函数与普通函数的区别</h4>
<p>1.普通函数作为对象的方法调用时，<code>this</code>指向它所属的对象。箭头函数中的<code>this</code>就<strong>永远指向</strong>它定义时所处的全局执行环境中的<code>this</code></p>
<p>2…call()/.apply()/.bind()无法改变箭头函数中this的指向。</p>
<p>3.箭头函数不能作为构造函数使用（原因：① JS内部首先会先生成一个对象；② 再把函数中的this指向该对象；③ 然后执行构造函数中的语句；④ 最终返回该对象实例。但是！！因为箭头函数没有自己的<code>this</code>，）</p>
<p>4.箭头函数没有自己的arguments，<strong>可以在箭头函数中使用rest参数代替arguments对象，来访问箭头函数的参数列表！！</strong></p>
<p>5.<strong>箭头函数没有原型prototype</strong></p>
<p>6.箭头函数不能用作Generator函数，不能使用yeild关键字</p>
<p>拓展：</p>
<h5 id="arguments">arguments</h5>
<p>因为arguments这个对象不能显式创建。arguments对象只有函数开始时才可用。</p>
<p>虽然arguments对象并不是一个数组（类数组），但是访问单个参数的方式与访问数组元素的方式相同</p>
<p><strong>arguments还有属性callee，length和迭代器Symbol。</strong></p>
<p><strong>callee</strong> 属性是 <strong>arguments</strong> 对象的一个成员，仅当相关函数正在执行时才可用。<strong>callee</strong> 属性的初始值就是正被执行的** Function** 对象。实现匿名的递归函数。</p>
<h5 id="rest运算符和spread操作符">rest运算符和spread操作符</h5>
<p>rest运算符用于获得传递给函数的参数列表，是一个数组。spread操作符主要用于数组构造和解构，以及在调用时将数组填入函数参数。</p>
<p>应用</p>
<pre class="language-none"><code class="language-none">let arrs1 &#x3D; [&#39;aa&#39;, &#39;bb&#39;];
let arrs2 &#x3D; [&#39;cc&#39;, &#39;dd&#39;];

&#x2F;&#x2F; 合并数组
let arrs &#x3D; [...arrs1, ...arrs2];
console.log(arrs); &#x2F;&#x2F; [&#39;aa&#39;, &#39;bb&#39;, &#39;cc&#39;, &#39;dd&#39;]

&#x2F;&#x2F; 析构数组
let param1, param2;
[param1, ...param2] &#x3D; arrs1;

console.log(param1); &#x2F;&#x2F; aa
console.log(param2); &#x2F;&#x2F; [&#39;bb&#39;]

把类数组对象转换成数组，
function testFunc() &#123;
   &#x2F;&#x2F; 转换成数组
   var toArray &#x3D; [...arguments];
   console.log(toArray); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;]
   toArray.push(&#39;11&#39;);   &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;11&#39;]
   console.log(toArray);
 &#125;;
 &#x2F;&#x2F; 函数调用
 testFunc(&#39;a&#39;, &#39;b&#39;);
数组的深度拷贝
var arr1 &#x3D; [1, 2];
var arr2 &#x3D; arr1;
arr1.push(3);
console.log(arr1); &#x2F;&#x2F; [1, 2, 3]
console.log(arr2); &#x2F;&#x2F; [1, 2, 3]
 字符串转数组
 var str &#x3D; &#39;kongzhi&#39;;
var arr &#x3D; [...str];
console.log(arr); &#x2F;&#x2F; [&quot;k&quot;, &quot;o&quot;, &quot;n&quot;, &quot;g&quot;, &quot;z&quot;, &quot;h&quot;, &quot;i&quot;]
解构赋值
&#x2F;&#x2F; 解构数组
var arr &#x3D; [&#39;aa&#39;, &#39;bb&#39;, &#39;cc&#39;];
let [a1, a2, a3] &#x3D; arr;
console.log(a1); &#x2F;&#x2F; aa
console.log(a2); &#x2F;&#x2F; bb
console.log(a3); &#x2F;&#x2F; cc

&#x2F;&#x2F; 对象解构
var o &#x3D; &#123;a: 1, b: 2&#125;;
var &#123;a, b&#125; &#x3D; o;
console.log(a);  &#x2F;&#x2F; 1
console.log(b);  &#x2F;&#x2F; 2</code></pre>
<h3 id="Vue">Vue</h3>
<h4 id="vue的三要素有哪些？"><strong>vue的三要素有哪些？</strong></h4>
<p>响应式、模板引擎、渲染。</p>
<p>渲染数据最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值。</p>
<h4 id="Vue-常用指令">Vue 常用指令</h4>
<p>使用了 vue 的指令后，表达式是 JS 表达式，变量是 VUE 实例中的数据属性。</p>
<pre class="language-none"><code class="language-none">v-if指令：v-if指令是根据条件表达式的值来执行元素的插入或者删除行为。
v-show指令
v-else指令
v-for指令：：基于一个数组渲染一个列表
v-model:让表单元素和数据实现双向绑定（映射关系）
v-bind指绑定属性，注意冒号后面跟标签的属性，属性后面的等号指向数据，它可以简写为 :class, :href。用于响应地更新 HTML 特性。 是单向绑定，它在绑定文本时，当data中的数据发生变化时，页面中的数据也相应改变，但页面中的数据改变不会影响到data。
v-on指令用于给监听DOM事件，它的用语法和v-bind是类似的，例如监听&lt;a&gt;元素的点击事件：
Vue.js为最常用的两个指令v-bind和v-on提供了缩写方式。v-bind指令可以缩写为一个冒号，v-on指令可以缩写为@符号。
v-text指令主要是防止页面首次加载时 &#123;&#123;&#125;&#125; 出现在页面上。将对象中数据变量值显示在绑定的标签内容上。
computed：
计算属性用来监听多个数据，每次页面加载，计算属性中的函数立即执行，但是只要原数据不被修改，那么，就不会触发重新计算，计算属性会使用计算后的缓存结果，只当原数据修改时，才会重新计算并将结果缓存起来。计算属性的计算结果可以当做data中的数据一样使用。

计算属性用来监听多个属性，我们也可以使用它来监听一个属性，但是页面加载即执行计算并不符合我们的需求，如何只在数据被修改后出发相应事件，vue提供给我们的是watch，即侦听属性。

vue提供给我们$refs来获取DOM元素</code></pre>
<h4 id="Model-View-VM">Model View VM</h4>
<p>Model 是数据, data<br>
View 是模板<br>
VM 是 vm = new Vue();</p>
<p>VM 用来连接数据和视图, 视图的输入框绑定了v-model, 用户输入后会改变data;</p>
<p>Model改变也会同步视图更新相关的依赖, 双向绑定就是vm起了作用</p>
<p><img src="https://oscimg.oschina.net/oscnet/bf38a328257bc88e39ee2887f9fc0d41b62.jpg" alt="bf38a328257bc88e39ee2887f9fc0d41b62.jpg"></p>
<h4 id="vue中ref的作用">vue中ref的作用</h4>
<p>本页面获取dom元素，获取子组件中的data，调用子组件中的方法</p>
<h4 id="vue的生命周期">vue的生命周期</h4>
<pre class="language-bash" data-language="bash"><code class="language-bash">Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。通俗说就是 Vue 实例从创建到销毁的过程，就是生命周期。
用户使用new Vue<span class="token punctuation">(</span><span class="token punctuation">)</span>新建一个vue实例，或父实例实例化子组件，确认组件的父子组件关系，将父组件的自定义事件传递给子组件，提供将render函数转化为vnode的方法
beforeCreate: vue元素的挂载元素el和数据都为undefined，还未初始化；
created：vue实例的数据对象data有了，el还没有；
beforeMount：vue实例的<span class="token variable">$el</span>和data都初始化了，但是还挂载在之前的虚拟dom节点上，data.message还未替换；
mounted：vue实例挂载完成，data.message成功渲染。
更新前后：data变化时会触发beforeUpdate和updated方法；
销毁前后：beforeDestory和destoryed，在执行destoryed方法后，对data的改变不会触发周期函数，说明vue实例已经解除了事件监听以及dom绑定，但是dom结构依然存在；
vue生命周期的作用：
他的生命周期中有多个事件钩子，让我们控制整个vue实例的过程时更容易形成良好的逻辑。
生命周期钩子的一些使用方法：
beforeCreate：loading事件，在加载实例时触发。
created：初始化完成事件，异步请求。
mounted：挂载元素，获取dom节点
uptaded：对数据统一处理
beforeDestory：确认事件停止。
nextTick：更新数据后立即操作dom。</code></pre>
<p><img src="https://xin--images.oss-cn-hongkong.aliyuncs.com/images1/202203021107080.png" alt="image-20220302110747389"></p>
<p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="Vue 实例生命周期"></p>
<h5 id="vue父子组件加载的时候周期执行顺序？">vue父子组件加载的时候周期执行顺序？</h5>
<p>父-&gt;父-&gt;父beforeMount</p>
<p>子-&gt;子mounted-&gt;父mounted</p>
<p>父组件挂载到vue实例上之前，必须确保子组件挂载到父组件上</p>
<h4 id="vue的渲染过程">vue的渲染过程</h4>
<h4 id="computed和watch的区别">computed和watch的区别</h4>
<pre class="language-vue" data-language="vue"><code class="language-vue">computed
计算结果并返回，只有当被计算的属性发生改变时才会触发（即：计算属性的结果会被缓存，除非依赖的响应属性变化才会重新及孙）
watch
 监听某一个值，当被监听的值发生变化时，执行相关操作。（与computed的区别是，watch更加适用于监听某一个值得变化，并做对应操作，比如请求后太接口等。而computed适用于计算已有的值并返回结果。）

监听简单数据类型：
data()&#123;
      return&#123;
        &#39;first&#39;:2
      &#125;
    &#125;,
    watch:&#123;
      first()&#123;
        console.log(this.first)
      &#125;
    &#125;,</code></pre>
<h4 id="json和xml数据的区别">json和xml数据的区别</h4>
<p>重轻，带宽，交互，数据描述性。</p>
<pre class="language-none"><code class="language-none">1、数据体积方面：xml是重量级的，json是轻量级的，传递的速度更快些。。
2、数据传输方面：xml在传输过程中比较占带宽，json占带宽少，易于压缩。
3、数据交互方面：json与javascript的交互更加方便，更容易解析处理，更好的进行数据交互
4、数据描述方面：json对数据的描述性比xml较差
5、xml和json都用在项目交互下，xml多用于做配置文件，json用于数据交互。</code></pre>
<h4 id="v-show-和v-if">v-show 和v-if</h4>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">		<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> v<span class="token operator">-</span><span class="token parameter"><span class="token keyword">if</span>：不满足条件，不会渲染dom</span> <span class="token operator">=></span> 单次判断 <span class="token operator">--</span><span class="token operator">></span>
        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> v<span class="token operator">-</span><span class="token function-variable function">show</span><span class="token operator">:</span> <span class="token parameter">隐藏dom</span> <span class="token operator">=></span> 多次切换<span class="token punctuation">,</span>（不能用于权限操作）<span class="token operator">--</span><span class="token operator">></span>
        <span class="token operator">&lt;</span>button v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">"val == 1"</span><span class="token operator">></span>按钮一<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>
        <span class="token operator">&lt;</span>button v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">"val == 2"</span><span class="token operator">></span>按钮二<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>
        <span class="token operator">&lt;</span>button v<span class="token operator">-</span>show<span class="token operator">=</span><span class="token string">"type"</span><span class="token operator">></span>type为<span class="token boolean">true</span>显示<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>
        <span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">"changeType()"</span><span class="token operator">></span>改变type<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>

v<span class="token operator">-</span><span class="token keyword">if</span>判断是否加载，可以减轻服务器的压力，在需要时加载<span class="token punctuation">,</span>但有更高的切换开销<span class="token punctuation">;</span>v<span class="token operator">-</span>show调整<span class="token constant">DOM</span>元素的<span class="token constant">CSS</span>的dispaly属性，可以使客户端操作更加流畅，但有更高的初始渲染开销。如果需要非常频繁地切换，则使用 v<span class="token operator">-</span>show 较好；如果在运行时条件很少改变，则使用 v<span class="token operator">-</span><span class="token keyword">if</span> 较好。

v<span class="token operator">-</span><span class="token keyword">if</span>底层采用的是appendChild来实现的，v<span class="token operator">-</span>show通过样式的display控制标签的显示，正因为实现方式上面有差异，导致了他们的加载速度方面产生了差异；
加载性能：v<span class="token operator">-</span><span class="token keyword">if</span>加载速度更快，v<span class="token operator">-</span>show加载速度慢
切换开销：v<span class="token operator">-</span><span class="token keyword">if</span>切换开销大，v<span class="token operator">-</span>show切换开销小
v<span class="token operator">-</span><span class="token keyword">if</span>是惰性的，它是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建，如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。
v<span class="token operator">-</span>show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 <span class="token constant">CSS</span> 进行切换。
一般来说，v<span class="token operator">-</span><span class="token keyword">if</span>有更高的切换开销，而v<span class="token operator">-</span>show有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用v<span class="token operator">-</span>show较好，如果在运行时条件很少改变，则使用v<span class="token operator">-</span><span class="token keyword">if</span>较好。</code></pre>
<h4 id="vue中如何解析模板？"><strong>vue中如何解析模板？</strong></h4>
<p>**<br>
1、模板是什么？**</p>
<p>模板的本质是字符串，最开始是以字符串形式存在的，</p>
<p>它与html格式相似，却又存在很大区别，html是静态的，而模板中因为存在着一些循环、判断等逻辑，所以它是可以动态展示数据的，</p>
<p>模板最终还需要转换成html，以便显示。</p>
<p><strong>2、render函数</strong></p>
<p>因为字符串并不能处理逻辑，也因为模板需要转换成html渲染出来，这些都需要js来完成，</p>
<p>所以需要先将模板转换成js代码，这写需要通过一个js函数（render函数）来处理的。</p>
<p><img src="https://img2018.cnblogs.com/blog/1699448/201908/1699448-20190829164839823-1275201676.png" alt="img"></p>
<p>render函数解析：</p>
<p>​      ①模板中所有信息都包含在了render函数中</p>
<p>​      ②this即 vm</p>
<p>​      ③price即 this.price， 即 vm.price， 即data中的price</p>
<p>​      ④_c即 this._c，即 vm._c</p>
<h4 id="v-model双向数据绑定">v-model双向数据绑定</h4>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>v-model原理<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span>
    <span class="token comment">&lt;!-- 1. 双向数据绑定 --></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>请输入名字<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
    显示值：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>uName<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">
        <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
        <span class="token comment">// 劫持一个对象</span>
        Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">"username"</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// 取值，搜集，数据被操作了，可以获取到</span>
            <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"取值"</span><span class="token punctuation">)</span>
            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
            <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"设置值"</span><span class="token punctuation">)</span>
                document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"uName"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerText <span class="token operator">=</span> val<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
        <span class="token comment">// 获取键盘弹起事件</span>
        document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"keyup"</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token comment">// event</span>
            obj<span class="token punctuation">.</span>username <span class="token operator">=</span> event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre>
<h4 id="vue是如何监听到data的每个属性变化的？"><strong>vue是如何监听到data的每个属性变化的？</strong></h4>
<p>通过**Object.defineProperty()**方法实现，<strong>Object.defineProperty()</strong> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</p>
<p>它接收的第三个参数中含有两个函数，分别是set()和get()，在这两个函数中就可以添加自定义的监听逻辑，从而达到监听数据变化的目的。</p>
<p>vue通过遍历data属性，在遍历函数中，利用**Object.defineProperty()**将每一个data属性绑定在vue对象上，同时添加监听逻辑，这样vue就可以监听到data属性的变化。</p>
<pre class="language-none"><code class="language-none">var vm&#x3D; &#123;&#125;;
var data &#x3D; &#123;
    name:&#39;zhangsan&#39;,
    age:20
&#125;;
var key;
for(key in data)&#123;
    (function(key)&#123; &#x2F;&#x2F; 命中闭包，保证key的独立空间
        Object.defineProperty(vm, key, &#123;
            get:funtion()&#123;
                &#x2F;&#x2F; 此处可写监听逻辑
                return data[key];
            &#125;,
            set:function(newVal)&#123;
                &#x2F;&#x2F; 此处可写监听逻辑
                data[key] &#x3D; newVal;
            &#125;
        &#125;)
    &#125;)(key)
&#125;</code></pre>
<h4 id="虚拟dom-》真实dom（dispatch-算法）">虚拟dom=》真实dom（dispatch()算法）</h4>
<p>虚拟dom，vue2.0才有，跨平台特性：本质js对象，</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 1.初始化patch(container, vnode)  虚拟dom-->真实dom</span>
<span class="token comment">// 2.更新 update(vnode, newVnode)</span>
<span class="token keyword">function</span> <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">vnode</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 虚拟dom组成三要素</span>
    <span class="token keyword">let</span> tag <span class="token operator">=</span> vnode<span class="token punctuation">.</span>tag     <span class="token comment">// 目标元素 ul</span>
    <span class="token keyword">let</span> attrs <span class="token operator">=</span> vnode<span class="token punctuation">.</span>attrs <span class="token operator">||</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// 属性</span>
    <span class="token keyword">let</span> children <span class="token operator">=</span> vnode<span class="token punctuation">.</span>children <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>   <span class="token comment">// 子节点</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>tag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 1.创建对应的dom</span>
    <span class="token keyword">let</span> elem <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span>
    <span class="token keyword">let</span> attrName
    <span class="token comment">// 给dom添加属性</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>attrName <span class="token keyword">in</span> attrs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>attrs<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>attrName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            elem<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span>attrName<span class="token punctuation">,</span> attrs<span class="token punctuation">[</span>attrName<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 将子元素添加到目标之上</span>
    children<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">childVnode</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
        elem<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token function">createElement</span><span class="token punctuation">(</span>childVnode<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> elem
<span class="token punctuation">&#125;</span>

<span class="token keyword">function</span> <span class="token function">updateChildren</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> newVnode</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> children <span class="token operator">=</span> vnode<span class="token punctuation">.</span>children <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">// 现有节点</span>
    <span class="token keyword">let</span> newChildren <span class="token operator">=</span> newVnode<span class="token punctuation">.</span>children <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">// 新节点</span>

    children<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">childrenVnode<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>
        <span class="token comment">// 循环每一项</span>
        <span class="token keyword">let</span> newChildrenVnode  <span class="token operator">=</span> newChildren<span class="token punctuation">[</span>index<span class="token punctuation">]</span>
        <span class="token comment">// 第一层没有变化</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>childrenVnode <span class="token operator">===</span> newChildrenVnode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// 深层次对比=>递归</span>
            <span class="token function">updateChildren</span><span class="token punctuation">(</span>childrenVnode<span class="token punctuation">,</span> newChildrenVnode<span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// 两个tag不一样</span>
            <span class="token function">replaceNode</span><span class="token punctuation">(</span>childrenVnode<span class="token punctuation">,</span> newChildrenVnode<span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

虚拟dom是如何提升Vue渲染速度？
将原来的直接操作dom（对浏览器的性能影响较大），变成js对象的操作（执行效率上的问题，对性能影响很小）
</code></pre>
<h4 id="订阅发布模式">订阅发布模式</h4>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 订阅器模型</span>
<span class="token keyword">let</span> Dep <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    clientList<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token comment">// 容器</span>
    <span class="token comment">// 添加订阅</span>
    <span class="token function-variable function">listen</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> fn</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 有没有数据</span>
        <span class="token comment">// 短路表达式  fn:附送消息</span>
        <span class="token comment">// true就直接出括号，false继续执行</span>
        <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>clientList<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>clientList<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token comment">// 发布</span>
    <span class="token function-variable function">trigger</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">let</span> key <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">,</span>
            fns <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>clientList<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token comment">// 如果没有这个人，这个人没有关注任何消息</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fns <span class="token operator">||</span> fns<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> fn<span class="token punctuation">;</span> fn <span class="token operator">=</span> fns<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 数据劫持</span>
<span class="token keyword">let</span> <span class="token function-variable function">dataHi</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">&#123;</span> data<span class="token punctuation">,</span> tag<span class="token punctuation">,</span> datakey<span class="token punctuation">,</span> selector <span class="token punctuation">&#125;</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">,</span>
        el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span>selector<span class="token punctuation">)</span><span class="token punctuation">;</span>

    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> datakey<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 取值</span>
        <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"取值"</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> value<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"设置值"</span><span class="token punctuation">)</span>
            value <span class="token operator">=</span> val<span class="token punctuation">;</span>
            <span class="token comment">// 发布,告诉目标对象并把新值传过去</span>
            Dep<span class="token punctuation">.</span><span class="token function">trigger</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
    <span class="token comment">// 订阅</span>
    Dep<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">text</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        el<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> text
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>
<h4 id="数据的可观测（data-具体）">数据的可观测（data()具体）</h4>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// Vue原理分析(四) ———— 变化侦测</span>
<span class="token comment">// data() &#123;&#125;</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Observer</span> <span class="token punctuation">&#123;</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value
        <span class="token keyword">if</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token comment">// 数组的逻辑</span>
        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>
            <span class="token comment">// 对象的逻辑</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">walk</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token function">walk</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// &#123;name: '小明', age: 18&#125;</span>
        <span class="token keyword">const</span> keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keys<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token function">defineReactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 循环 让对象的每一个属性都变成可观测的</span>
<span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// arguments.length为函数实参个数,这里相当于少声明了一个val(简单方法)</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        val <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span>  <span class="token comment">// 对象的某个值</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> val <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token comment">// 递归</span>
        <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>

    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>
        enumerable<span class="token operator">:</span>  <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 可枚举</span>
        configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 可改变</span>
        <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>key<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">属性被读取了</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> val
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token function">set</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>key<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">属性被修改了,新值为</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>newVal<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
            val <span class="token operator">=</span> newVal
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>
<h4 id="nextTick">$nextTick()</h4>
<pre class="language-none"><code class="language-none">$nextTick()
dom更新之后延迟回调
A &#x3D;&gt; B
B要加载到A中来
$nextTick(&#123;
 this.$refs.b.dn()
&#125;)</code></pre>
<h4 id="单页与多页的区别及优缺点">单页与多页的区别及优缺点</h4>
<pre class="language-none"><code class="language-none">单页应用(SPA): 只有一个主页面的应用
组件 &#x3D;&gt; 页面片段
跳转 &#x3D;&gt; 刷新局部资源
场景 &#x3D;&gt; PC端

优点：
a. 体验好，快
b. 改动内容，不用加载整个页面
c. 前后端分离
d. 效果可以很炫酷

缺点：
a. 不利于SEO
b. 初次加载比较慢
c. 页面复杂度很高

多页应用：
整页刷新</code></pre>
<h4 id="v-if与v-for">v-if与v-for</h4>
<p>v-for优先级 &gt; v-if</p>
<h4 id="Vue-router与location-href有什么区别">Vue-router与location.href有什么区别?</h4>
<p>location.href: 简单方便，刷新页面（跳外链）<br>
Vue-router: 实现了按需加载，减少了dom消耗 （内部页面）<br>
Vue-router =&gt; js原生history</p>
<h4 id="params和query">params和query</h4>
<p>params：<br>
name引入<br>
<a target="_blank" rel="noopener" href="http://this.$route.parms.xxx">this.$route.parms.xxx</a><br>
类似于post传参，不显示的，加密的<br>
刷新会丢失数据</p>
<p>query：<br>
path引入 ,<br>
<a target="_blank" rel="noopener" href="http://this.$route.query.xxx">this.$route.query.xxx</a><br>
类似于get传参,显示在浏览器中<br>
刷新不丢失数据</p>
<h4 id="created与mounted">created与mounted</h4>
<p>created: 在模板渲染成html之前调用 =&gt; 初始化某些值，再渲染成视图<br>
mounted: 在模板渲染成html之后调用 =&gt; 初始化之后，对dom节点的一些操作</p>
<h4 id="route，router"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mtext>，</mtext></mrow><annotation encoding="application/x-tex">route，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">，</span></span></span></span>router</h4>
<p>$router：是VueRouter的实例 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">.</mi><mi>p</mi><mi>u</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">router.push()
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord">.</span><span class="mord mathnormal">p</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span>route：当前router跳转的对象，当前页的信息 name, path, query,parms</p>
<h4 id="每一个属性的可观测性的实现">每一个属性的可观测性的实现</h4>
<p>数据变化–及时侦测到</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// Vue原理分析(四) ———— 变化侦测</span>
<span class="token comment">// data() &#123;&#125;</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Observer</span> <span class="token punctuation">&#123;</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value
        <span class="token keyword">if</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token comment">// 数组的逻辑</span>
        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>
            <span class="token comment">// 对象的逻辑</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">walk</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token function">walk</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// &#123;name: '小明', age: 18&#125;</span>
        <span class="token keyword">const</span> keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keys<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token function">defineReactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 循环 让对象的每一个属性都变成可观测的</span>
<span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// arguments.length为函数实参个数,这里相当于少声明了一个val(简单方法)</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        val <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span>  <span class="token comment">// 对象的某个值</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> val <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token comment">// 递归</span>
        <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>

    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>
        enumerable<span class="token operator">:</span>  <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 可枚举</span>
        configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 可改变</span>
        <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>key<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">属性被读取了</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> val
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token function">set</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>key<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">属性被修改了,新值为</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>newVal<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
            val <span class="token operator">=</span> newVal
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>
<h4 id="响应式—发布订阅模式-数据劫持">响应式—发布订阅模式+数据劫持</h4>
<p>模板用的什么数据源—》订阅</p>
<p>数据发生变化了—》发布，</p>
<pre class="language-none"><code class="language-none">&#x2F;&#x2F; 订阅器模型
let Dep &#x3D; &#123;
    clientList: &#123;&#125;,  &#x2F;&#x2F; 容器
    &#x2F;&#x2F; 添加订阅
    listen: function (key, fn) &#123;
        &#x2F;&#x2F; 有没有数据
        &#x2F;&#x2F; 短路表达式  fn:附送消息
        &#x2F;&#x2F; true就直接出括号，false继续执行
        (this.clientList[key] || (this.clientList[key] &#x3D; [])).push(fn);
    &#125;,
    &#x2F;&#x2F; 发布
    trigger: function () &#123;
        let key &#x3D; Array.prototype.shift.call(arguments),
            fns &#x3D; this.clientList[key];
            &#x2F;&#x2F; 如果没有这个人，这个人没有关注任何消息
        if (!fns || fns.length &#x3D;&#x3D;&#x3D; 0) &#123;
            return false;
        &#125;
        for (let i &#x3D; 0, fn; fn &#x3D; fns[i++];) &#123;
            fn.apply(this, arguments)
        &#125;
    &#125;
&#125;
&#x2F;&#x2F; 数据劫持
let dataHi &#x3D; function (&#123; data, tag, datakey, selector &#125;) &#123;
    let value &#x3D; &#39;&#39;,
        el &#x3D; document.querySelector(selector);

    Object.defineProperty(data, datakey, &#123;
        &#x2F;&#x2F; 取值
        get: function () &#123;
            console.log(&quot;取值&quot;)
            return value;
        &#125;,
        set: function (val) &#123;
            console.log(&quot;设置值&quot;)
            value &#x3D; val;
            &#x2F;&#x2F; 发布,告诉目标对象并把新值传过去
            Dep.trigger(tag, val)
        &#125;
    &#125;)
    &#x2F;&#x2F; 订阅
    Dep.listen(tag, function(text)&#123;
        el.innerHTML &#x3D; text
    &#125;)
&#125;</code></pre>
<h3 id="Vuex">Vuex</h3>
<p>Vue.js应用程序的状态管理模式+库。</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token number">1</span>、state

保存vuex中的数据源，通过<span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state获取

<span class="token number">2</span>、getters

用于监听state中的值的变化，返回计算后的结果。getter的返回值会根据它的依赖被缓存起来

<span class="token number">3</span>、mutations

是修改state中的值得唯一方式

<span class="token number">4</span>、action 

官方建议提交一个actions，在actions中提交mutations再去修改状态值。 <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'add'</span><span class="token punctuation">)</span>

<span class="token comment">//this.$store.commit('add')</span>

<span class="token number">5</span>、modules 模块化</code></pre>
<h4 id="为什么vuex中推荐通过提交mutations的方式来修改state，而不是直接修改state？">为什么vuex中推荐通过提交mutations的方式来修改state，而不是直接修改state？</h4>
<pre class="language-none"><code class="language-none">因为state是实时更新的，mutations无法进行异步操作，而如果直接修改state的话是能够异步操作的，当你异步对state进行操作时，还没执行完，这时候如果state已经在其他地方被修改了，这样就会导致程序存在问题了。所以state要同步操作，通过mutations的方式限制了不允许异步。</code></pre>
<h4 id="Vuex是什么-什么场景使用？数据持久化">Vuex是什么?什么场景使用？数据持久化?</h4>
<p>是什么：全局状态管理，多个组件需要共享数据状态会用到<br>
场景：音乐播放器，登录状态校验，加入购物车。1兄弟间组件传值（子组件传给共同的父组件，父组件再传给子组件）2.跨级组件传值</p>
<p>events-bus，数据量不大，且不需要同步。</p>
<p>数据持久化: 存在本地缓存</p>
<pre class="language-none"><code class="language-none">引入一个store实例，并把这个实例挂载到vue实例中，使用了Vue.use(vuex) 所以必定有一个install方法，install&#x3D;&gt;注册流程，Store
</code></pre>
<h3 id="vue-router-跳转方式">vue router 跳转方式</h3>
<pre class="language-none"><code class="language-none">跳转到不同的url，但这个方法会向history栈添加一个记录，点击后退会返回到上一个页面。
 this.$router.push(&#123;path: &#39;&#x2F;home&#x2F;sort&#x2F;detail&#39;,query:&#123;id: &#39;abc&#39;&#125;&#125;)     
 获取参数 &#123;&#123;this.$route.query.userId&#125;&#125;
 this.$router.push(&#123;name: &#39;detail&#39;,params:&#123;id: &#39;abc&#39;&#125;&#125;)
获取参数：&#123;&#123;this.$route.params.userId&#125;&#125;
ps:
query要用path来引入，params要用name来引入：eg

this.$router.push(&#123;
   name:&quot;detail&quot;,
   params:&#123;
    name:&#39;nameValue&#39;,
    code:10011
 &#125;
&#125;);
　query更加类似于我们ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示

1、this.$router.replace()

同样是跳转到指定的url，但是这个方法不会向history里面添加新的记录，点击返回，会跳转到上上一个页面。上一个记录是不存在的。

2、this.$router.go(n)

相对于当前页面向前或向后跳转多少个页面,类似 window.history.go(n)。n可为正数可为负数。正数返回上一个页面
1) 根据路由路径（&#x2F;home&#x2F;sort&#x2F;detail）跳转 &lt;router-link :to&#x3D;&quot;&#123;path: &#39;&#x2F;home&#x2F;sort&#x2F;detail&#39;, query:&#123;id: &#39;abc&#39;&#125;&#125;&quot;&gt;点击查看子页面&lt;&#x2F;router-link&gt;

2) 根据路由名称（detail）跳转 &lt;router-link :to&#x3D;&quot;&#123;name: &#39;detail&#39;, params:&#123;id: &#39;abc&#39;&#125;&#125;&quot;&gt;点击查看子页面&lt;&#x2F;router-link&gt;    :to&#x3D;&quot;&quot; 可以实现绑定动态的 路由 和 参数
</code></pre>
<h5 id="分布式路由">分布式路由</h5>
<h3 id="webpack">webpack</h3>
<h4 id="概念问题一：什么是webpack和grunt和gulp有什么不同">概念问题一：什么是webpack和grunt和<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=gulp&amp;spm=1001.2101.3001.7020">gulp</a>有什么不同</h4>
<p>答案：Webpack是一个模块打包器，他可以递归的打包项目中的所有模块，最终生成几个打包后的文件。他和其他的工具最大的不同在于他支持code-splitting、模块化(AMD，ESM，CommonJs)、全局分析。</p>
<h4 id="概念问题二：什么是bundle-什么是chunk，什么是module">概念问题二：什么是bundle,什么是chunk，什么是<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=module&amp;spm=1001.2101.3001.7020">module</a>?</h4>
<p>答案：bundle是由webpack打包出来的文件，chunk是指webpack在进行模块的依赖分析的时候，代码分割出来的代码块。module是开发中的单个模块。</p>
<h4 id="概念问题三：什么是Loader-什么是Plugin">概念问题三：什么是Loader?什么是Plugin?</h4>
<p>答案：</p>
<p>1）Loaders是用来告诉webpack如何转化处理某一类型的文件，并且引入到打包出的文件中。</p>
<p>2）Plugin是用来自定义webpack打包过程的方式，一个插件是含有apply方法的一个对象，通过这个方法可以参与到整个webpack打包的各个流程(生命周期)。</p>
<h4 id="配置问题-如何可以自动生成webpack配置？">配置问题:如何可以自动生成webpack配置？</h4>
<p>答案： webpack-cli /vue-cli /etc …脚手架工具</p>
<h4 id="开发问题一：webpack-dev-server和http服务器如nginx有什么区别">开发问题一：webpack-dev-server和http服务器如nginx有什么区别?</h4>
<p>答案：webpack-dev-server使用内存来存储webpack开发环境下的打包文件，并且可以使用模块热更新，他比传统的http服务对开发更加简单高效。</p>
<h4 id="开发问题二-什么-是模块热更新？">开发问题二:什么 是模块热更新？</h4>
<p>答案:模块热更新是webpack的一个功能，他可以使得代码修改过后不用刷新浏览器就可以更新，是高级版的自动刷新浏览器。</p>
<h4 id="优化问题一：什么是长缓存？在webpack中如何做到长缓存优化？">优化问题一：什么是长缓存？在webpack中如何做到长缓存优化？</h4>
<p>答案：浏览器在用户访问页面的时候，为了加快加载速度，会对用户访问的静态资源进行存储，但是每一次代码升级或是更新，都需要浏览器去下载新的代码，最方便和简单的更新方式就是引入新的文件名称。在webpack中可以在output纵输出的文件指定chunkhash,并且分离经常更新的代码和框架代码。通过NameModulesPlugin或是HashedModuleIdsPlugin使再次打包文件名不变。</p>
<h4 id="优化问题二：什么是Tree-shaking-CSS可以Tree-shaking吗">优化问题二：什么是Tree-shaking?CSS可以Tree-shaking吗?</h4>
<p>答案：Tree-shaking是指在打包中去除那些引入了，但是在代码中没有被用到的那些死代码。在webpack中Tree-shaking是通过uglifySPlugin来Tree-shaking JS。Css需要使用Purify-CSS。</p>
<h4 id="作用">作用</h4>
<p>依赖管理：方便引用第三方模块、让模块更容易复用、避免全局注入导致的冲突、避免重复加载或加载不需要的模块。</p>
<p>合并代码：把各个分散的模块集中打包成大文件，减少HTTP的请求链接数，配合UglifyJS可以减少、优化代码的体积。</p>
<p>各路插件：babel把ES6+转译成ES5-，eslint可以检查编译期的错误……</p>
<h4 id="实现原理">实现原理</h4>
<p>原理：最简单地说，就是分析代码，找到require、exports、define等“关键词”，并替换成对应模块的“引用“-</p>
<p>webpack的理念就是一切皆模块，把一大堆的css,js在一个总入口文件require引入，剩下的事情，webpack会自动处理，包括所有模块的前后端依赖关系打包压缩合并成一个js，公共代码抽离另外生成位js，某些制定的js单独打包…这些模块可以是css/js/image/fonts。</p>
<h4 id="babel原理">babel原理</h4>
<p>babel工作分为三大阶段：</p>
<p>解析<br>
将代码字符串解析为抽象语法树；<br>
将整个代码分割成语法单元，进而再分析语法单元之间的关系；<br>
这一步会验证语法的正确性，同时由字符串变为对象结构后更有利于精准地分析以及进行代码结构调整。<br>
转换<br>
遍历抽象树，对抽象语法树进行再变换；这一步是babel或者其他编译器中最为复杂的过程。<br>
生成<br>
递归变换后的抽象语法树再生成代码字符串。</p>
<h4 id="plugin和loader的区别">plugin和loader的区别</h4>
<p>loader 用于加载某些资源文件。</p>
<p>因为 webpack 只能理解 JavaScript 和 JSON 文件，对于其他资源例如 css，图片，或者其他的语法集，比如 jsx， coffee，是没有办法加载的。 这就需要对应的loader将资源转化，加载进来。从字面意思也能看出，loader是用于加载的，它作用于一个个文件上。</p>
<p>plugin 用于扩展webpack的功能。</p>
<p>它直接作用于 webpack，扩展了它的功能。当然loader也是变相的扩展webpack，但是它只专注于转化文件（transform）这一个领域。而plugin的功能更加的丰富，而不仅局限于资源的加载。</p>
<h3 id="HTTP">HTTP</h3>
<h4 id="网络分层结构">网络分层结构</h4>
<p>计算机网络体系大致分为三种，OSI七层模型、TCP/IP四层模型和五层模型。一般面试的时候考察比较多的是五层模型。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/1Wxib6Z0MOJbCRJHmV85OCNfEPABbFy4jWaicoBxAibzialdR51yuOzbm1xhzkWH2hs80OCCN0lvxicwH4v4M05SFFw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p>TCP/IP五层模型：应用层、传输层、网络层、数据链路层、物理层。</p>
<ul>
<li><strong>应用层</strong>：为应用程序提供交互服务。在互联网中的应用层协议很多，如域名系统DNS、HTTP协议、SMTP协议等。</li>
<li><strong>传输层</strong>：负责向两台主机进程之间的通信提供数据传输服务。传输层的协议主要有传输控制协议TCP和用户数据协议UDP。</li>
<li><strong>网络层</strong>：选择合适的路由和交换结点，确保数据及时传送。主要包括IP协议。</li>
<li><strong>数据链路层</strong>：在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装成帧</strong>，在两个相邻节点间的链路上传送帧。</li>
<li><strong>物理层</strong>：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和物理设备的差异。</li>
</ul>
<h4 id="常见状态码及含义">常见状态码及含义</h4>
<p>1xx 信息性状态码，表示接收的请求正在处理</p>
<p>100（请求已被部分处理）、101（切换协议）<br>
2xx 成功状态码，表示请求正常处理完毕</p>
<p>200（请求成功）、204（请求处理成功，但没有内容返回）、206（返回指定范围的内容）<br>
3xx 重定向状态码，表示需要进行附加操作以完成请求</p>
<p>301（永久重定向）、302（临时重定向）、303（临时重定向，但要求使用GET方法）、304（请求资源未更改，直接使用缓存）<br>
4xx 客户端错误状态码，表示服务器无法处理请求</p>
<p>400（请求出错）、401（未授权）、403（被服务器拒绝访问，跨域）、404（服务器上没有请求的资源）<br>
5xx 服务器错误状态码，表示服务器请求出错</p>
<p>500（服务器内部错误）、503（服务器暂时无法处理请求）<br>
这里需要注意一下 200 和 304 在浏览器协商缓存下的作用。</p>
<h4 id="GET和POST的区别">GET和POST的区别</h4>
<p>安全性：Get是不安全的，因为在传输过程，参数被放在请求的URL中，请求一次；Post的所有操作对用户来说都是不可见的，参数放在requestbody中，请求两次<br>
数据量：Get传送的数据量较小，这主要是因为受URL长度限制；Post传送的数据量较大，一般被默认为不受限制。<br>
参数类型：Get只接受ASCII字符；而Post没有限制。<br>
效率：Get执行效率却比Post方法好。Get是form提交的默认方法。<br>
部分浏览器：GET请求会被浏览器主动cache，而POST请求不会，除非手动设置。GET请求的参数会被完整保存在浏览器的历史纪录里面，而POST参数不会。</p>
<p>回退：GET在浏览器回退时是无害的，而POST会再次提交请求。</p>
<p>GET产生一个TCP数据包；POST产生两个TCP数据包。</p>
<p>总的来说：</p>
<p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p>
<p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p>
<h4 id="http和https的区别，https的优点缺点">http和https的区别，https的优点缺点</h4>
<pre class="language-none"><code class="language-none">Http：超文本传输协议（Http，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。设计Http最初的目的是为了提供一种发布和接收HTML页面的方法。它可以使浏览器更加高效。Http协议是以明文方式发送信息的，如果黑客截取了Web浏览器和服务器之间的传输报文，就可以直接获得其中的信息。

Https：是以安全为目标的Http通道，是Http的安全版。Https的安全基础是SSL。SSL协议位于TCP&#x2F;IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层：SSL记录协议（SSL Record Protocol），它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。SSL握手协议（SSL Handshake Protocol），它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。

HTTP与HTTPS的区别
1、HTTP是超文本传输协议，信息是明文传输，HTTPS是具有安全性的SSL加密传输协议。
2、HTTPS协议需要ca申请证书，一般免费证书少，因而需要一定费用。
3、HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样。前者是80，后者是443。
4、HTTP连接是无状态的，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，安全性高于HTTP协议。


https的优点
尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：
1）使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；
2）HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。
3）HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。
4）谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。

Https的缺点
1）Https协议握手阶段比较费时，会使页面的加载时间延长近。
2）Https连接缓存不如Http高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响；
3）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。
4）Https协议的加密范围也比较有限。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</code></pre>
<h4 id="HTTPS工作原理：">HTTPS工作原理：</h4>
<pre class="language-none"><code class="language-none">客户使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。 
web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥）传输给客户端。
客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。 
客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过服务器的公钥来加密会话密钥，并传送给服务器。 
web 服务器通过自己的私钥解密出会话密钥。 web 服务器通过会话密钥加密与客户端之间的通信。 </code></pre>
<h4 id="HTTP状态码有哪些？">HTTP状态码有哪些？</h4>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/1Wxib6Z0MOJbCRJHmV85OCNfEPABbFy4jtiaKYpP94XeYQUD2UQbdqQp45icPBWQEs3wWtn62UVFicYOg92ozxOcBQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<h4 id="HTTP1-0和HTTP1-1的区别">HTTP1.0和HTTP1.1的区别?</h4>
<ul>
<li><strong>长连接</strong>：HTTP1.0默认使用短连接，每次请求都需要建立新的TCP连接，连接不能复用。<strong>HTTP1.1支持长连接，复用TCP连接，允许客户端通过同一连接发送多个请求</strong>。不过，这个优化策略也存在问题，当一个队头的请求不能收到响应的资源时，它将会阻塞后面的请求。这就是“<strong>队头阻塞</strong>”问题。</li>
<li><strong>断点续传</strong>：HTTP1.0 <strong>不支持断点续传</strong>。HTTP1.1 新增了 <strong>range</strong> 字段，用来指定数据字节位置，<strong>支持断点续传</strong>。</li>
<li><strong>错误状态响应码</strong>：在HTTP1.1中新增了24个错误状态响应码，如<code>409（Conflict）</code>表示请求的资源与资源的当前状态发生冲突、<code>410（Gone）</code>表示服务器上的某个资源被永久性的删除。</li>
<li><strong>Host头处理</strong>：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名。到了HTTP1.1时代，虚拟主机技术发展迅速，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址，故HTTP1.1增加了HOST信息。</li>
</ul>
<h4 id="HTTP1-1和-HTTP2-0的区别？">HTTP1.1和 HTTP2.0的区别？</h4>
<p>HTTP2.0相比HTTP1.1支持的特性：</p>
<ul>
<li><strong>新的二进制格式</strong>：HTTP1.1 基于文本格式传输数据；HTTP2.0采用二进制格式传输数据，解析更高效。</li>
<li><strong>多路复用</strong>：在一个连接里，允许同时发送多个请求或响应，<strong>并且这些请求或响应能够并行的传输而不被阻塞</strong>，避免 HTTP1.1 出现的”队头堵塞”问题。</li>
<li><strong>头部压缩</strong>，HTTP1.1的header带有大量信息，而且每次都要重复发送；HTTP2.0 把header从数据中分离，并封装成头帧和数据帧，<strong>使用特定算法压缩头帧</strong>，有效减少头信息大小。并且HTTP2.0**在客户端和服务器端记录了之前发送的键值对，对于相同的数据，不会重复发送。*<em>比如请求a发送了所有的头信息字段，请求b则*<em>只需要发送差异数据</em></em>，这样可以减少冗余数据，降低开销。</li>
<li><strong>服务端推送</strong>：HTTP2.0允许服务器向客户端推送资源，无需客户端发送请求到服务器获取。</li>
</ul>
<h4 id="HTTPS与HTTP的区别？">HTTPS与HTTP的区别？</h4>
<ol>
<li>HTTP是超文本传输协议，信息是<strong>明文传输</strong>；HTTPS则是具有<strong>安全性</strong>的ssl加密传输协议。</li>
<li>HTTP和HTTPS用的端口不一样，HTTP端口是80，HTTPS是443。</li>
<li>HTTPS协议<strong>需要到CA机构申请证书</strong>，一般需要一定的费用。</li>
<li>HTTP运行在TCP协议之上；HTTPS运行在SSL协议之上，SSL运行在TCP协议之上。</li>
</ol>
<h4 id="客户端怎么知道给证书公钥的是服务器呢？怎么判断第三方伪造证书">客户端怎么知道给证书公钥的是服务器呢？怎么判断第三方伪造证书</h4>
<p>数字证书本身已经提供方案了，数字证书中除了包含加密之后的服务器公钥，权威机构的信息之外，还包含了证书内容的签名(先通过Hash函数计算得到证书数字摘要，然后用权威机构私钥加密数字摘要得到数字签名)，签名计算方法以及证书对应的域名。这样一来，客户端收到证书之后：</p>
<p>使用权威机构的公钥解密数字证书，得到证书内容（服务器的公钥）以及证书的数字签名，然后根据证书上描述的计算证书签名的方法计算一下当前证书的签名，与收到的签名作对比，如果一样，表示证书一定是服务器下发的，没有被中间人篡改过。因为中间人虽然有权威机构的公钥，能够解析证书内容并篡改，但是篡改完成之后中间人需要将证书重新加密，但是中间人没有权威机构的私钥，无法加密，强行加密只会导致客户端无法解密，如果中间人强行乱修改证书，就会导致证书内容和证书签名不匹配。所以证书签名就能判断证书是否被篡改</p>
<p>简单过程<strong>浏览器验证过程</strong>：</p>
<ol>
<li>获取证书，得到证书内容、证书签名算法和数字签名。</li>
<li>用CA机构的公钥<strong>对数字签名解密</strong>（由于是浏览器信任的机构，所以浏览器会保存它的公钥）。</li>
<li>用证书里的签名算法<strong>对证书内容进行hash运算</strong>。</li>
<li>比较解密后的数字签名和对证书内容做hash运算后得到的哈希值，相等则表明证书可信。\</li>
</ol>
<h4 id="HTTP是使用TCP还是UDP">HTTP是使用TCP还是UDP</h4>
<p><strong>虽然HTTP最初被设计成无状态的协议，似乎更加适合UDP，但是下面一些原因使TCP成为首选：</strong></p>
<ul>
<li>HTTP使用TCP，因为当从远程服务器获得文件，网页不应该在中途丢弃，而应该按照HTTP客户端的顺序交付。</li>
<li>HTTP也可以使用UDP，但通常不会，如果包括网页第一部分的UDP数据包丢失了，那么它就不会被重传。**当我们使用UDP协议时，需要在应用层编写一些代码来处理丢失数据包的重传。但我们并不想让web浏览器应用层来承担这项工作，让它只承担实际的渲染页面工作，**这也符合解耦的设计。所以我们使用TCP。</li>
</ul>
<p><img src="https://pic1.zhimg.com/50/v2-71e2b180adf8bdc57f5c7df0bb3a4b01_720w.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-71e2b180adf8bdc57f5c7df0bb3a4b01_720w.jpg?source=1940ef5c" alt="img"></p>
<p>简言之，<strong>HTTP并没有重复实现任何基本的TCP特性。HTTP被定义在TCP上运行，从广义上可以理解:HTTP可以在任何类似TCP协议上运行</strong>（实现了面向连接，完整性，纠错，滑动窗口的协议）</p>
<h4 id="输入一个网站的域名地址发生了什么？">输入一个网站的域名地址发生了什么？</h4>
<pre class="language-bash" data-language="bash"><code class="language-bash">输入一个域名后对于一些浏览器来说会从历史记录、书签等地方，找到已经输入的字符串可能对应的URL，如果没找到：
就去浏览器缓存：浏览器缓存DNS会记录一段时间，然而操作系统并没有告诉浏览器每个DNS记录的生存时间，因此浏览器会将其缓存一段固定的时间（一般在2到30分钟之间）
操作系统缓存：如果浏览器缓存不包含所需的记录，则搜索操作系统中的DNS缓存和hosts文件。
路由器缓存：请求继续到您的路由器，路由器通常具有自己的DNS缓存。
ISP DNS缓存：检查的下一个是ISP的DNS缓存，这里自然也会有一个缓存。如果没有，则否则递归依次向根域名服务器、顶级域名服务器、权限域名服务器发起查询请求，最终返回IP地址给本地域名服务器，需要知道dns解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑dns-prefetch优化
本地域名服务器将得到的IP地址返回给操作系统，同时自己也将IP地址缓存起来。操作系统将 IP 地址返回给浏览器，同时自己也将IP地址缓存起来。浏览器得到域名对应的IP地址，得到ip地址后就开始与服务器建立TCP连接了，

TCP三次连接：第一次握手，首先是客户端随机生成一个起始序列号x，向这个ip地址发送一个包含标志位SYN<span class="token operator">=</span><span class="token number">1</span>，序列号seq<span class="token operator">=</span>x。第一次握手前客户端的状态为CLOSE，第一次握手后客户端的状态为SYN-SENT。此时服务端的状态为LISTEN。第二次握手：服务端在收到客户端发来的报文后，会随机生成一个服务端的起始序列号y，然后给客户端回复一段报文，其中包括标志位SYN<span class="token operator">=</span><span class="token number">1</span>，ACK<span class="token operator">=</span><span class="token number">1</span>，序列号seq<span class="token operator">=</span>y，确认号ack<span class="token operator">=</span>x+1。第二次握手前服务端的状态为LISTEN，第二次握手后服务端的状态为SYN-RCVD，此时客户端的状态为SYN-SENT。（其中SYN<span class="token operator">=</span><span class="token number">1</span>表示要和客户端建立一个连接，ACK<span class="token operator">=</span><span class="token number">1</span>表示确认序号有效）。第三次握手：客户端收到服务端发来的报文后，会再向服务端发送报文，其中包含标志位ACK<span class="token operator">=</span><span class="token number">1</span>，序列号seq<span class="token operator">=</span>x+1，确认号ack<span class="token operator">=</span>y+1。第三次握手前客户端的状态为SYN-SENT，第三次握手后客户端和服务端的状态都为ESTABLISHED。此时连接建立完成。
请求的方法差异：
get和post的区别
get和post虽然本质都是tcp/ip，但两者除了在http层面外，在tcp/ip层面也有区别。
get会产生一个tcp数据包，post两个
具体就是：
get请求时，浏览器会把headers和data一起发送出去，服务器响应200（返回数据），
post请求时，浏览器先发送headers，服务器响应100 continue， 浏览器再发送data，服务器响应200（返回数据）。
涉及到五层因特网协议栈：
从应用层的发送http请求，到传输层通过三次握手建立tcp/ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。
负载均衡：对于大型项目，如果并发量比较大的话，用户发起的请求就会通过反向代理服务器，根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后反向代理服务器等待实际服务器的HTTP响应，并将它反馈给用户
后端的操作：一般有的后端是有统一的验证的，如安全拦截，跨域验证，如果这一步不符合规则，就直接返回了相应的http报文（如拒绝请求等）。然后当验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等）。等程序执行完毕后，就会返回一个http响应包（一般这一步也会经过多层封装）。然后就是将这个包从后端发送到前端，完成交互
http报文结构：
通过报文发送数据，报文的内容有请求行，请求头部，空行（CRLF），请求数据；服务器接收到保温后，返回相应的报文，报文由状态行，响应头部，空行，响应数据。
请求行：请求码，请求方法。
一般来说，请求头部和响应头部是匹配分析的。
譬如，请求头部的Accept要和响应头部的Content-Type匹配，否则会报错
譬如，跨域请求时，请求头部的Origin要匹配响应头部的Access-Control-Allow-Origin，否则会报跨域错误
譬如，在使用缓存时，请求头部的If-Modified-Since、If-None-Match分别和响应头部的Last-Modified、ETag对应




三、传输数据
连接后，客户端向服务端发起 HTTP 请求，服务器接收到请求后，返回请求静态资源，并同时调用 apache 服务器请求接口数据。

四、关闭 TCP 连接

数据传输完成，客户端与服务端进行四次挥手，关闭连接。

五、渲染页面

对于浏览器根据服务端返回的静态资源，浏览器使用 Native GUI 引擎渲染 HTML 和 CSS ；使用 JS 引擎加载 JS 。



浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow<span class="token punctuation">(</span>回流<span class="token punctuation">)</span>和repain<span class="token punctuation">(</span>重绘<span class="token punctuation">)</span>。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow<span class="token punctuation">;</span>当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。

JS的解析是由浏览器中的JS解析引擎完成的。JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务<span class="token punctuation">(</span>synchronous<span class="token punctuation">)</span>和异步任务<span class="token punctuation">(</span>asynchronous<span class="token punctuation">)</span>。JS的执行机制就可以看做是一个主线程加上一个任务队列<span class="token punctuation">(</span>task queue<span class="token punctuation">)</span>。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈<span class="token punctuation">;</span>异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环<span class="token punctuation">(</span>Event loop<span class="token punctuation">)</span>。

浏览器在解析过程中，如果遇到请求外部资源时，如图像,iconfont,JS等。浏览器将重复1-6过程下载该资源。请求过程是异步的，并不会影响HTML文档进行加载，但是当文档加载过程中遇到JS文件，HTML文档会挂起渲染过程，不仅要等到文档中JS文件加载完毕还要等待解析执行完毕，才会继续HTML的渲染过程。原因是因为JS有可能修改DOM结构，这就意味着JS执行完成前，后续所有资源的下载是没有必要的，这就是JS阻塞后续资源下载的根本原因。CSS文件的加载不影响JS文件的加载，但是却影响JS文件的执行。JS代码执行前浏览器必须保证CSS文件已经下载并加载完毕


四次挥手
A的应用进程先向其TCP发出连接释放报文段（FIN<span class="token operator">=</span><span class="token number">1</span>，seq<span class="token operator">=</span>u），并停止再发送数据，主动关闭TCP连接，进入FIN-WAIT-1（终止等待1）状态，等待B的确认。
B收到连接释放报文段后即发出确认报文段（ACK<span class="token operator">=</span><span class="token number">1</span>，ack<span class="token operator">=</span>u+1，seq<span class="token operator">=</span>v），B进入CLOSE-WAIT（关闭等待）状态，此时的TCP处于半关闭状态，A到B的连接释放。
A收到B的确认后，进入FIN-WAIT-2（终止等待2）状态，等待B发出的连接释放报文段。
B发送完数据，就会发出连接释放报文段（FIN<span class="token operator">=</span><span class="token number">1</span>，ACK<span class="token operator">=</span><span class="token number">1</span>，seq<span class="token operator">=</span>w，ack<span class="token operator">=</span>u+1），B进入LAST-ACK（最后确认）状态，等待A的确认。
A收到B的连接释放报文段后，对此发出确认报文段（ACK<span class="token operator">=</span><span class="token number">1</span>，seq<span class="token operator">=</span>u+1，ack<span class="token operator">=</span>w+1），A进入TIME-WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL（最大报文段生存时间）后，A才进入CLOSED状态。B收到A发出的确认报文段后关闭连接，若没收到A发出的确认报文段，B就会重传连接释放报文段。

</code></pre>
<h4 id="TCP三次握手">TCP三次握手</h4>
<p>最开始的时候，客户端和服务端都是Closed(关闭)状态，准备发送连接请求前，Server会进入LISTEN(监听)状态。</p>
<ul>
<li><strong>第一次握手：</strong> 客户端(Client)会给服务端(Server)发送请求报文段，并指定同步序列号SYN = 1，初始序号为seq = x，（seq里面就是字节的序号），同时TCP的客户端进程进入SYN-SENT(同步已发送)状态。</li>
<li><strong>第二次握手：</strong> 服务端收到客户端发送的请求报文SYN后，会向客户端发送一个SYN报文作为应答，表示同意建立连接，同时指定了自己的SYN = 1， ACK = 1，还会向客户端发送seq = y，来表示自己的一个初始序号，同时也会告诉客户端下一次应该从哪开始发送的确认序号，由于客户端发送过来的初始序号seq = x, 所以确认序号ack = x + 1，这时，TCP的服务端进入SYN-RCVD(同步收到)状态。</li>
<li><strong>第三次握手：</strong> 客户端收到服务端的确认报文之后，会再次向服务端发送确认信息，表示已经收到。所以ACK = 1, seq = x + 1, ack = y + 1。TCP建立连接，客户端和服务器进入ESTAB-LISTEND(已建立连接状态)状态。</li>
</ul>
<h4 id="为什么三次握手？">为什么三次握手？</h4>
<p>因为假如之握手两次的话，客户端第一次向服务端发送建立请求的请求，可能由于网络延时的原因滞留了，而客户端迟迟没有收到服务端的响应就会认为这个请求失效了，客户端会再次往服务端发送一个连接请求，然后服务端正常响应了。之后的某个时间，客户端第一次给服务端发送的请求到达了服务端，服务端就会响应客户端的连接，客户端发现自己发送过这个请求就会忽略，而此时已经两次握手成功了，服务端会一直等待响应，而客户端也不知道，这样就造成了资源的浪费。</p>
<h4 id="TCP四次挥手">TCP四次挥手</h4>
<p>1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。<br>
2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。<br>
3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。<br>
4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ACK = 1, ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。<br>
5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。<br>
6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/1Wxib6Z0MOJbCRJHmV85OCNfEPABbFy4jBHwsEdl9eOVbcqohJk80ZIq2NsH0Y1hTKGL7Liafszvdp65cHOUqic1w/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/1Wxib6Z0MOJbCRJHmV85OCNfEPABbFy4jcsBA9hUMJ3DWD4zqRDfE5WkTu1CeedicrLrW9NWdjV0ThR9EFFczmHg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<h4 id="第四次挥手为什么要等待2MSL？">第四次挥手为什么要等待2MSL？</h4>
<ul>
<li><strong>保证A发送的最后一个ACK报文段能够到达B</strong>。这个<code>ACK</code>报文段有可能丢失，B收不到这个确认报文，就会超时重传连接释放报文段，然后A可以在<code>2MSL</code>时间内收到这个重传的连接释放报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入到<code>CLOSED</code>状态，若A在<code>TIME-WAIT</code>状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到B重传的连接释放报文段，所以不会再发送一次确认报文段，B就无法正常进入到<code>CLOSED</code>状态。</li>
<li><strong>防止已失效的连接请求报文段出现在本连接中</strong>。A在发送完最后一个<code>ACK</code>报文段后，再经过2MSL，就可以使这个连接所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现旧的连接请求报文段。</li>
</ul>
<h4 id="为什么是四次挥手？">为什么是四次挥手？</h4>
<p>因为当Server端收到Client端的<code>SYN</code>连接请求报文后，可以直接发送<code>SYN+ACK</code>报文。<strong>但是在关闭连接时，当Server端收到Client端发出的连接释放报文时，很可能并不会立即关闭SOCKET</strong>，所以Server端先回复一个<code>ACK</code>报文，告诉Client端我收到你的连接释放报文了。只有等到Server端所有的报文都发送完了，这时Server端才能发送连接释放报文，之后两边才会真正的断开连接。故需要四次挥手。</p>
<h4 id="拥塞控制和流量控制">拥塞控制和流量控制</h4>
<p>拥塞避免：</p>
<p>慢开始，拥塞避免：初始时，拥塞窗口值为1，慢开始门限为16，在慢开始阶段，拥塞窗口呈指数增长，遇到慢开始门限时(如果超过了，就设置为门限值)，就改用拥塞避免算法，拥塞窗口按线性增长，遇到拥塞时门限值设为当前拥塞窗口的1/2，将拥塞窗口值重置为1。</p>
<p>快重传（直接重传），快恢复：当发送方接收到冗余的ACK时，就采用快重传和快恢复。快恢复：将拥塞窗口值和门限值都设为发生拥塞时窗口值得1/2，直接从拥塞算法开始。</p>
<p>流量控制：流量控制就是让发送方的发送速率不要太快，要让接收方来的及接收。原理是通过确认报文中窗口字段来控制发送方的发送速率，发送方的发送窗口大小不能超过接收方给出窗口大小。</p>
<h4 id="TCP的定义和UDP的区别">TCP的定义和UDP的区别</h4>
<p>TCP是传输控制协议。UDP是用户数据包协议</p>
<p><strong>安全的，可靠的，面向连接的传输。不安全的，不可靠的，无连接的传输</strong></p>
<p>可靠的服务，通过TCP连接传送的数据，无差错、不丢失，不重复，按序到达；UDP尽最大努力交付，不保证可靠交付。</p>
<p>TCP面向字节流，UDP则是面向报文的</p>
<p>TCP首部开销20字节； UDP的首部开销小，只有8个字节</p>
<p>TCP有<strong>拥塞控制</strong>；UDP没有拥塞控制，</p>
<h4 id="为什么需要WebSocket？">为什么需要WebSocket？</h4>
<p>因为 HTTP 协议有一个缺陷：通信只能由客户端发起。这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用<a target="_blank" rel="noopener" href="https://www.pubnub.com/blog/2014-12-01-http-long-polling/">&quot;轮询&quot;</a>：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。于是就有了WebSocket，它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息</p>
<p>在main.js中建立一个websocket连接，同时将socket实例挂在到vue原型链上，以便在组件中可以调用相关方法，在组件中调用注册回调函数，将函数注册到，然后调用send方法发送数据的方法，返回一个res。关闭页面后注意取消注册</p>
<h4 id="JWT">JWT</h4>
<p>jwt 有三部分组成：A.B.C</p>
<p>A：Header，{“type”:“JWT”,“alg”:“HS256”} typ表示类型为jwt格式,alg表示加密方式为hs256,exp表示时间</p>
<p>B：playload，存放信息，比如，用户id，过期时间等等，可以被解密，不能存放敏感信息</p>
<p>C: 签证，A和B加上秘钥 加密而成，只要秘钥不丢失，可以认为是安全的。</p>
<p>jwt 验证，主要就是验证C部分 是否合法。</p>
<h4 id="JWT的优点和缺点">JWT的优点和缺点</h4>
<pre class="language-none"><code class="language-none">解决跨域问题：这种基于Token的访问策略可以克服cookies的跨域问题。
服务端无状态可以横向扩展，Token可完成认证，无需存储Session。
系统解耦，Token携带所有的用户信息，无需绑定一个特定的认证方案，只需要知道加密的方法和密钥就可以进行加密解密，有利于解耦。
防止跨站点脚本攻击，没有cookie技术，无需考虑跨站请求的安全问题。
缺点：
jwt一旦发送不能撤回发送的信息
不能防止CSRF攻击等</code></pre>
<h4 id="JWT实现原理">JWT实现原理</h4>
<pre class="language-none"><code class="language-none">把header和playload分别使用base64url编码,接着用&#39;.&#39;把两个编码后的字符串连接起来，再把这拼接起来的字符串配合密钥进行HMAC SHA-256算法加密，最后再次base64编码下，这就拿到了签名sign. 最后把header和playload和sign用&#39;.&#39;连接起来就生成了整个JWT

后端服务校验jwtToken是否有权访问接口服务，进行解密认证，如校验访问者的userid，首先用将字符串按.号切分三段字符串，分别得到header和playload和sign。然后将header.playload拼装用密钥和HAMC SHA-256算法进行加密然后得到新的字符串和sign进行比对，如果一样就代表数据没有被篡改，然后从头部取出exp对存活期进行判断，如果超过了存活期就返回空字符串，如果在存活期内返回userid的值

整个jwt的结构是由header.playload.sign连接组成，只有sign是用密钥加密的，而所有的信息都在header和playload中可以直接获取，sign的作用只是校验header和playload的信息是否被篡改过，所以jwt不能保护数据，但以上的特性可以很好的应用在权限认证上
</code></pre>
<h4 id="关于-token-的存储问题">关于 token 的存储问题</h4>
<p>JWT：</p>
<p>csrf 攻击无法获取第三方的 cookie，而是直接使用 cookie进行查询的时候会自动携带 cookie。</p>
<p>xss攻击通过代码注入可以获取 cookie。需要设置转义。</p>
<p>方式一、客户端使用 cookie直接认证，需要设置 cookie为 httpOnly，可以防止 xss攻击。但是无法防止 csrf攻击。需要设置伪随机数 X-XSRF-TOKEN。（推荐！不 需要处理 xss，并且xsrf 随机数有完善的应用机制）</p>
<p>方式二、 客户端使用 auth授权头认证，token存储在 cookie中，需要防止xss攻击。可以防止 csrf攻击，因为 csrf只能在请求中携带 cookie，而这里必须从 cookie中拿出相应的值并放到 authorization 头中。实际上cookie不能跨站（同源政策）被取出，因此可以避免 csrf 攻击。（适用于 ajax请求或者 api请求，可以方便的设置 auth头）</p>
<p>方式三、可以将token存储在 localstorage里面，需要防止xss攻击。实现方式可以在一个统一的地方复写请求头，让每次请求都在header中带上这个token， 当token失效的时候，后端肯定会返回401，这个时候在你可以在前端代码中操作返回登陆页面，清除localstorage中的token。（适用于 ajax请求或者 api请求，可以方便的存入 localstorage）</p>
<p>设置 HTTPS，可以防止提交时的用户名或者密码被拦截或读取。</p>
<h4 id="localstorage和sessionstorage">localstorage和sessionstorage</h4>
<p>vuex存储在内存，localstorage（本地存储）则以文件的方式存储在本地,永久保存；sessionstorage( 会话存储 ) ,临时保存。localStorage和sessionStorage只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理</p>
<h4 id="JWT-流程">JWT 流程</h4>
<ol>
<li>浏览器发起请求登陆</li>
<li>服务端验证身份，根据算法，将用户标识符打包生成 token, 并且返回给浏览器</li>
<li>浏览器发起请求获取用户资料，把刚刚拿到的 token 一起发送给服务器</li>
<li>服务器发现数据中有 token，验明正身</li>
<li>服务器返回该用户的用户资料</li>
</ol>
<p>你发现了吗？好些并没有什么区别，除了 session 需要服务端存储一份，而 JWT 不需要</p>
<p>但实际上区别大了去了</p>
<ol>
<li>session 存储在服务端占用服务器资源，而 JWT 存储在客户端</li>
<li>session 存储在 Cookie 中，存在伪造跨站请求伪造攻击的风险</li>
<li>session 只存在一台服务器上，那么下次请求就必须请求这台服务器，不利于分布式应用</li>
<li>存储在客户端的 JWT 比存储在服务端的 session 更具有扩展性</li>
<li>…</li>
</ol>
<h4 id="jwt怎么让token在用户退出登录失效？">jwt怎么让token在用户退出登录失效？</h4>
<h5 id="1-客户端清除-token">1.客户端清除 token</h5>
<p>登出时在浏览器或者 APP 客户端清除 token。这种方法比较简单，无需后端操作。</p>
<p>但不经过服务器验证的客户端清除 token 操作会造成登出后使用原 token 仍有访问权限的问题，针对该问题，token 的过期时间可以设置尽可能短，以减少原 token 的有效的时间。</p>
<h5 id="2-白名单">2.白名单</h5>
<p>在 Redis 维护有效的 token，在 token 生成后就存入 Redis，登出时从 Redis 删除该 token。在验证  token 之前先查询白名单中是否有该 token，如果有则表明是有效的，然后进入解析 token 的逻辑。有点像有状态的 session 的味道了。</p>
<p>为了避免白名单不断变大，可以按照 jwt 中的过期时间来设置存入 Redis 的 token 的过期时间。</p>
<h5 id="3-黑名单">3.黑名单</h5>
<p>在 Redis 维护登出的无效 token，在验证 token 之前先查询黑名单中是否有该 token，如果没有表明是有效的，然后进入解析 token 的逻辑。</p>
<p>为了避免黑名单不断变大， 可以按照 jwt 中的过期时间来设置存入 Redis 的 token 的过期时间。</p>
<p>一般黑名单会比白名单占用的内存小。</p>
<h4 id="Cookie和Session的区别？">Cookie和Session的区别？</h4>
<ul>
<li><strong>作用范围不同</strong>，Cookie 保存在客户端，Session 保存在服务器端。</li>
<li><strong>有效期不同</strong>，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</li>
<li><strong>隐私策略不同</strong>，Cookie 存储在客户端，容易被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li>
<li><strong>存储大小不同</strong>， 单个 Cookie 保存的数据不能超过 4K；对于 Session 来说存储没有上限，但出于对服务器的性能考虑，Session 内不要存放过多的数据，并且需要设置 Session 删除机制。</li>
</ul>
<h4 id="sessionStorage、localStorage和cookie的区别"><strong>sessionStorage、localStorage和cookie的区别</strong></h4>
<p>共同点：都是保存在浏览器端、且同源的<br>
区别：<br>
1、cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下</p>
<p>2、存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</p>
<p>3、数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效(会话存储)；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭</p>
<p>4、作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的</p>
<p>5、web Storage支持事件通知机制，可以将数据更新的通知发送给监听者</p>
<p>6、web Storage的api接口使用更方便</p>
<p><img src="https://xin--images.oss-cn-hongkong.aliyuncs.com/images1/202203022007883.png" alt="image-20220302200700563"></p>
<p>vuex存储在内存，vuex用于组件之间的传值，localstorage，sessionstorage则主要用于不同页面之间的传值。当刷新页面（这里的刷新页面指的是 --&gt; F5刷新,属于清除内存了）时vuex存储的值会丢失，sessionstorage<strong><strong>页面关闭后就清除掉了</strong></strong></p>
<h4 id="什么是对称加密和非对称加密？">什么是对称加密和非对称加密？</h4>
<p><strong>对称加密</strong>：通信双方使用<strong>相同的密钥</strong>进行加密。特点是加密速度快，但是缺点是密钥泄露会导致密文数据被破解。常见的对称加密有<code>AES</code>和<code>DES</code>算法。</p>
<p><strong>非对称加密</strong>：它需要生成两个密钥，<strong>公钥和私钥</strong>。公钥是公开的，任何人都可以获得，而私钥是私人保管的。公钥负责加密，私钥负责解密；或者私钥负责加密，公钥负责解密。这种加密算法<strong>安全性更高</strong>，但是<strong>计算量相比对称加密大很多</strong>，加密和解密都很慢。常见的非对称算法有<code>RSA</code>和<code>DSA</code>。</p>
<h4 id="XSS和CSRF攻击">XSS和CSRF攻击</h4>
<h5 id="XSS">XSS</h5>
<p>跨域脚本攻击，指的是攻击者将攻击脚本代码恶意注入传给服务器，就比如填写表单时，填入一段script代码盗用cookie。</p>
<p>可以通过设置一个过滤器避免、采用含有HttpOnly标志的Cookie在HTTP响应头Set-Cookie。</p>
<h5 id="CSRF">CSRF</h5>
<p>跨域请求伪造，一般通过钓鱼链接。</p>
<p>防范CSRF可遵循以下几种规则:</p>
<p>Get 请求不对数据进行修改<br>
不让第三方网站访问到用户Cookie<br>
阻止第三方网站请求接口<br>
请求时附带验证信息，如验证码或Token(这种情况下会发送预检请求)</p>
<h5 id="XSS攻击，Cookie相关的字段，HttpOnly">XSS攻击，Cookie相关的字段，HttpOnly</h5>
<p>cookie中设置HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击。</p>
<h5 id="CSRF攻击，Cookie的SameSite字段">CSRF攻击，Cookie的SameSite字段</h5>
<p>Chrome 51 开始，浏览器的 Cookie 新增加了一个SameSite属性，用来防止 CSRF 攻击和用户追踪。Cookie 的SameSite属性用来限制第三方 Cookie，从而减少安全风险。</p>
<p>可以设置三个值：</p>
<p>Strict：完全禁止第三方Cookie<br>
Lax（Chrome默认）：只有导航到目标网址的 GET 请求才发送Cookie，这只包括三种情况：链接，预加载请求，GET 表单<br>
None：关闭该属性。不过，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效。</p>
<h3 id="Nginx">Nginx</h3>
<p>Nginx是一个HTTP服务器，可以将服务器上的静态文件（如HTML、图片）通过HTTP协议展现给客户端。</p>
<p>通过第三方服务器访问服务器集群的内容，但是我们并不知道是哪一台服务器提供的内容，此种代理方式称为<strong>反向代理</strong></p>
<p>什么是负载均衡（upstream模块）</p>
<p>公司会建立很多的服务器，这些服务器组成了服务器集群，然后，当用户访问网站的时候，先访问一个中间服务器，再让这个中间服务器在服务器集群中选择一个压力较小的服务器，然后将该访问请求引入选择的服务器所以，用户每次访问，都会保证服务器集群中的每个服务器压力趋于平衡，分担了服务器压力，避免了服务器崩溃的情况</p>
<p><strong>nginx -s stop</strong></p>
<p>nginx -s reload</p>
<p>nginx -t</p>
<h3 id="操作系统">操作系统</h3>
<h4 id="线程、进程、协程的区别">线程、进程、协程的区别</h4>
<p>概念：**进程是资源单位，线程是执行单位；**协程：算法或技术</p>
<h5 id="1-进程和线程的区别">1.进程和线程的区别</h5>
<ul>
<li>调度：进程是资源管理的基本单位，线程是程序执行的基本单位。</li>
<li>切换：线程上下文切换比进程上下文切换要快得多。</li>
<li>拥有资源： 进程是拥有资源的一个独立单位，线程不拥有系统资源，但是可以访问隶属于进程的资源。</li>
<li>系统开销： 创建或撤销进程时，系统都要为之分配或回收系统资源，如内存空间，I/O设备等，OS所付出的开销显著大于在创建或撤销线程时的开销，进程切换的开销也远大于线程切换的开销。</li>
</ul>
<h5 id="2-协程与线程的区别">2.协程与线程的区别</h5>
<ul>
<li>线程和进程都是同步机制，而协程是异步机制。</li>
<li>线程是抢占式，而协程是非抢占式的。需要用户释放使用权切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。</li>
<li>一个线程可以有多个协程，一个进程也可以有多个协程。</li>
<li>协程不被操作系统内核管理，而完全是由程序控制。线程是被分割的CPU资源，协程是组织好的代码流程，线程是协程的资源。但协程不会直接使用线程，协程直接利用的是执行器关联任意线程或线程池。</li>
<li>协程能保留上一次调用时的状态。</li>
</ul>
<h4 id="死锁"><strong>死锁</strong></h4>
<p>互斥，请求与保持，不可剥夺，循环等待</p>
<h4 id="什么是用户态和内核态？">什么是用户态和内核态？</h4>
<p>内核态：内核态运行的程序可以访问计算机的任何数据和资源，不受限制，包括外围设备</p>
<p>用户态：用户态运行的程序只能受限地访问内存，只能直接读取用户程序的数据，并且不允许访问外围设备，用户态下的 CPU 不允许独占，也就是说 CPU 能够被其他程序获取。</p>
<h4 id="select、poll-和-epoll-之间的区别">select、poll 和 epoll 之间的区别?</h4>
<p>（1）select：时间复杂度 O(n)</p>
<p>select 仅仅知道有 I/O 事件发生，但并不知道是哪几个流，所以只能<strong>无差别轮询所有流</strong>，找出能读出数据或者写入数据的流，并对其进行操作。所以 select 具有 O(n) 的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。</p>
<p>（2）poll：时间复杂度 O(n)</p>
<p>poll 本质上和 select 没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个 fd 对应的设备状态， 但是它没有最大连接数的限制，原因是它是<strong>基于<a href="">链表</a>来存储的</strong>。</p>
<p>（3）epoll：时间复杂度 O(1)</p>
<p>epoll 可以理解为 event poll，不同于忙轮询和无差别轮询，<strong>epoll 会把哪个流发生了怎样的 I/O 事件通知我们</strong>。所以说 epoll 实际上是事件驱动（每个事件关联上 fd）的。</p>
<blockquote>
<p>select，poll，epoll 都是 IO 多路复用的机制。I/O 多路复用就是通过一种机制监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），就通知程序进行相应的读写操作。但 select，poll，epoll 本质上都是同步 I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步 I/O 则无需自己负责进行读写，异步 I/O 的实现会负责把数据从内核拷贝到用户空间。</p>
</blockquote>
<h3 id="Ajax">Ajax</h3>
<p><img src="https://xin--images.oss-cn-hongkong.aliyuncs.com/images1/202203030009561.png" alt="image-20220303000922105"></p>
<h3 id="浏览器">浏览器</h3>
<h4 id="浏览器进程-线程模型">浏览器进程/线程模型</h4>
<p>浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程（某些情况下多个tab会合并进程）</p>
<p>进程可能包括主控进程，插件进程，GPU，tab页（浏览器内核）等等</p>
<pre class="language-none"><code class="language-none">Browser进程：浏览器的主进程（负责协调、主控），只有一个
第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
GPU进程：最多一个，用于3D绘制
浏览器渲染进程（内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）</code></pre>
<p>多线程的浏览器内核:每一个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程</p>
<pre class="language-none"><code class="language-none">GUI线程
JS引擎线程
事件触发线程
定时器线程
网络请求线程</code></pre>
<h4 id="浏览器多个页签之间通信">浏览器多个页签之间通信</h4>
<p>使用localStorage，cookie+setInterval()</p>
<p><strong>使用localStorage</strong></p>
<ul>
<li>localStorage是浏览器多个标签共用的存储空间，所以可以用来实现多标签之间的通信(ps：sessionStorage是会话级的存储空间，每个标签页都是单独的）。</li>
<li>在一个标签页里面使用 <strong>localStorage.setItem(key, value)</strong> 添加（修改、删除）内容；<br>
在另一个标签页里面监听 <strong>storage</strong>事件。<br>
即可得到 <strong>localStorage</strong>存储的值，实现不同标签页之间的通信。</li>
</ul>
<pre class="language-none"><code class="language-none">window.onstorage &#x3D; (e) &#x3D;&gt; &#123;console.log(e)&#125;
&#x2F;&#x2F; 或者这样
window.addEventListener(&#39;storage&#39;, (e) &#x3D;&gt; console.log(e))</code></pre>
<p><strong>cookie+setInterval()</strong></p>
<p>将要传递的信息存储在cookie中，每隔一定时间读取cookie信息，即可随时获取要传递的信息。</p>
<p>页签1：</p>
<pre class="language-none"><code class="language-none">&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;ipt&quot;&gt;  
&lt;input type&#x3D;&quot;button&quot; id&#x3D;&quot;btn&quot; value&#x3D;&quot;提交&quot;&gt;  
&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;  
    $(function()&#123;    
        $(&quot;#btn&quot;).click(function()&#123;    
            var ipt&#x3D;$(&quot;#ipt&quot;).val();    
            document.cookie&#x3D;&quot;name&#x3D;&quot;+ipt;    
        &#125;);    
    &#125;);    
&lt;&#x2F;script&gt;  </code></pre>
<p>页签2：</p>
<pre class="language-none"><code class="language-none">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;  
    $(function()&#123;   
        function getCookie(key) &#123;    
            return JSON.parse(&quot;&#123;\&quot;&quot; + document.cookie.replace(&#x2F;;\s+&#x2F;gim,&quot;\&quot;,\&quot;&quot;).replace(&#x2F;&#x3D;&#x2F;gim, &quot;\&quot;:\&quot;&quot;) + &quot;\&quot;&#125;&quot;)[key];    
        &#125;     
        setInterval(function()&#123;    
            console.log(&quot;name&#x3D;&quot; + getCookie(&quot;name&quot;));    
        &#125;, 10000);    
    &#125;);  
&lt;&#x2F;script&gt;  </code></pre>
<h4 id="webworker">webworker</h4>
<ul>
<li>我们都知道JavaScript是<strong>单线程</strong>的，但是浏览器是拥有过个线程的比如：gui渲染线程、JS引擎线程、事件触发线程、异步http请求线程。</li>
<li>webworker作为浏览器的一个新特性，可以提供一个<strong>额外的线程</strong>来执行一些js代码，并且不会影响到浏览器用户界面。</li>
<li>应用场景：比如页面中包含耗时较大的算法代码时，就会阻塞线程影响浏览器渲染等等。这时候就可把耗时代码，放到webworker(另一个线程)中执行。</li>
<li>注意，这种多线程能力不是JavaScript语言原生具有的，而是浏览器宿主环境提供的。</li>
<li>普通的webworker直接使用**<code>new Worker()</code><strong>即可创建，这种webworker是</strong>当前页面**专有的。然后还有种共享worker(SharedWorker)，这种是可以多个标签页、iframe共同使用的，接下来介绍如何使用SharedWorker实现标签页之间的通信。</li>
</ul>
<h4 id="SharedWorker">SharedWorker</h4>
<ul>
<li>SharedWorker可以被多个window共同使用，但必须保证这些标签页都是同源的(相同的协议，主机和端口号)</li>
<li>首先新建一个js文件<code>worker.js</code>，具体代码如下：</li>
</ul>
<pre class="language-none"><code class="language-none">&#x2F;&#x2F; sharedWorker所要用到的js文件，不必打包到项目中，直接放到服务器即可
let data &#x3D; &#39;&#39;
onconnect &#x3D; function (e) &#123;
  let port &#x3D; e.ports[0]
 
  port.onmessage &#x3D; function (e) &#123;
    if (e.data &#x3D;&#x3D;&#x3D; &#39;get&#39;) &#123;
      port.postMessage(data)
    &#125; else &#123;
      data &#x3D; e.data
    &#125;
  &#125;
&#125;</code></pre>
<ul>
<li>
<p>webworker端(暂且这样称呼)的代码就如上，只需注册一个onmessage监听信息的事件，客户端(即使用sharedWorker的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%A0%87%E7%AD%BE&amp;spm=1001.2101.3001.7020">标签</a>页)发送message时就会触发。</p>
</li>
<li>
<p>注意webworker无法在本地使用，出于浏览器本身的安全机制，所以我这次的示例也是放在服务器上的，<code>worker.js</code>和<code>index.html</code>在同一目录。</p>
</li>
<li>
<p>因为客户端和webworker端的通信不像<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=websocket&amp;spm=1001.2101.3001.7020">websocket</a>那样是全双工的，所以客户端发送数据和接收数据要分成两步来处理。示例中会有两个按钮，分别对应的向sharedWorker发送数据的请求以及获取数据的请求，但他们本质上都是相同的事件–发送消息。</p>
</li>
<li>
<p>webworker端会进行判断，传递的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE&amp;spm=1001.2101.3001.7020">数据</a>为’get’时，就把变量data的值回传给客户端，其他情况，则把客户端传递过来的数据存储到data变量中。下面是客户端的代码：</p>
</li>
</ul>
<pre class="language-none"><code class="language-none">&#x2F;&#x2F; 这段代码是必须的，打开页面后注册SharedWorker，显示指定worker.port.start()方法建立与worker间的连接
    if (typeof Worker &#x3D;&#x3D;&#x3D; &quot;undefined&quot;) &#123;
      alert(&#39;当前浏览器不支持webworker&#39;)
    &#125; else &#123;
      let worker &#x3D; new SharedWorker(&#39;worker.js&#39;)
      worker.port.addEventListener(&#39;message&#39;, (e) &#x3D;&gt; &#123;
        console.log(&#39;来自worker的数据：&#39;, e.data)
      &#125;, false)
      worker.port.start()
      window.worker &#x3D; worker
    &#125;
&#x2F;&#x2F; 获取和发送消息都是调用postMessage方法，我这里约定的是传递&#39;get&#39;表示获取数据。
window.worker.port.postMessage(&#39;get&#39;)
window.worker.port.postMessage(&#39;发送信息给worker&#39;)</code></pre>
<ul>
<li>页面A发送数据给worker，然后打开页面B，调用<code>window.worker.port.postMessage('get')</code>，即可收到页面A发送给worker的数据。</li>
<li>参考：<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FWeb_Workers_API%2FUsing_web_workers">https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers</a></li>
</ul>
<h4 id="浏览器-HTTP-缓存机制">浏览器(HTTP)缓存机制</h4>
<pre class="language-none"><code class="language-none">浏览器会根据 http response header 中的 Expires 和cahe-control 字段判断是否命中强缓存，如若命中，则直接从缓存中取资源，不会再去向服务器请求了。否则（没有命中强缓存），浏览器会发出一个条件请求，浏览器会在请求头中包含 If-Modified-Since 或 If-None-Match 字段，If-Modified-Since 即浏览器当初得到的 Last-Modified；If-None-Match即浏览器当初得到的 ETag。当服务器发现资源的更新时间晚于 If-Modified-Since 所提供的时间，或者资源在服务器端当前的 ETag 和 If-None-Match 提供的不符时，说明该资源需要向服务器重新请求了。否则，浏览器将不需要重新下载整个资源，只需要从缓存中去加载这个资源，这时响应的http code 为 304（304 Not Modified）。</code></pre>
<h5 id="缓存的概念知识">缓存的概念知识</h5>
<ul>
<li>缓存的分类：服务器缓存(代理服务器缓存、CDN 缓存)，第三方缓存，浏览器缓存等。</li>
<li>缓存的相关术语：
<ul>
<li>缓存命中率：从缓存中得到数据的请求数与所有请求数的比率。理想状态是越高越好。</li>
<li>过期内容：超过设置的有效时间，被标记为 ‘陈旧’ 的内容。通常过期内容不能用于回复客户端的请求，必须重新向源服务器请求新的内容或者验证缓存的内容是否仍然可用。</li>
<li>验证：验证缓存中的过期内容是否仍然有效，验证通过的话刷新过期时间或策略。</li>
<li>失效：失效就是把内容从缓存中移除。当内容发生改变时就必须移除失效的内容。</li>
</ul>
</li>
<li>另： 浏览器缓存是代价最小的，因为浏览器缓存依赖的是客户端，而几乎不耗费服务器端的资源(极端情况下相当于纯静态页面)。</li>
</ul>
<h5 id="缓存的作用">缓存的作用</h5>
<ul>
<li>减少网络带宽消耗</li>
<li>降低服务器压力</li>
<li>减少网络延迟，加快页面打开速度</li>
</ul>
<h5 id="缓存机制">缓存机制</h5>
<ul>
<li>强缓存优先于协商缓存，强缓存生效则使用强缓存，若强缓存失败，则进行协商缓存</li>
<li>协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存<br>
<img src="https://www.cnblogs.com/programmerzhang/p/14037869.html" alt="img"></li>
</ul>
<p><img src="https://img2020.cnblogs.com/blog/1133619/202011/1133619-20201125190324164-367321755.png" alt="img"></p>
<p>缓存策略 图片来源：IMWeb前端</p>
<h5 id="涉及缓存机制的HTTP-header">涉及缓存机制的HTTP-header</h5>
<h5 id="Expires（过期时间）-强缓存机制">Expires（过期时间）(强缓存机制)</h5>
<ul>
<li>
<p><strong>值</strong>：是一个GMT时间格式的绝对时间，<code>Expires</code> 的日期时间必须是格林威治时间（GMT），而不是本地时间。举例：<code>Expires: Fri, 30 Oct 1998 14:19:41</code></p>
</li>
<li>
<p><strong>作用</strong>：告诉缓存器相关副本在多长时间内是新鲜的。过了这个时间，缓存器就会向源服务器发送请求，检查文档是否被修改。</p>
</li>
<li>
<p><strong>兼容性</strong>：几乎所有的缓存服务器都支持Expires（过期时间）属性</p>
</li>
<li>
<p><strong>规则</strong>：基于客户最后查看副本的时间（最后访问时间）或者根据服务器上文档最后被修改的时间</p>
</li>
<li>
<p>应用：</p>
<ul>
<li>对于设置静态图片文件（例如导航栏和图片按钮）缓存特别有用；因为这些图片修改很少，你可以给它们设置一个特别长的过期时间，这会使你的网站对用户变得相应非常快</li>
<li>对于控制有规律改变的网页也很有用，例如：你每天早上6点更新新闻页，你可以设置副本的过期时间也是这个时间，这样缓存服务器就知道什么时候去取一个更新版本，而不必让用户去按浏览器的&quot;刷新&quot;按钮。</li>
<li>过期时间头信息属性值只能是HTTP格式的日期时间，其他的都会被解析成当前时间&quot;之前&quot;，副本会过期</li>
</ul>
</li>
<li>
<p>局限性</p>
<p>：虽然过期时间属性非常有用，但是它还是有些局限，</p>
<ul>
<li>首先：是牵扯到了日期，这样Web服务器的时间和缓存服务器的时间必须是同步的，如果有些不同步，要么是应该缓存的内容提前过期了，要么是过期结果没及时更新。</li>
<li>如果你设置的过期时间是一个固定的时间，如果你返回内容的时候又没有连带更新下次过期的时间，那么之后所有访问请求都会被发送给源Web服务器，反而增加了负载和响应时间</li>
</ul>
</li>
</ul>
<h5 id="Cache-Control（缓存控制）-强缓存机制">Cache-Control（缓存控制）(强缓存机制)</h5>
<ul>
<li>
<p>值：</p>
<pre class="language-none"><code class="language-none">max-age&#x3D;[秒]</code></pre>
<p>— 执行缓存被认为是最新的最长时间。</p>
<ul>
<li>相对时间，不是绝对时间</li>
<li>单位是秒：从请求时间 开始到过期时间之间的秒数。</li>
</ul>
</li>
<li>
<p><strong>作用</strong>：让网站的发布者可以更全面的控制他们的内容，并定位过期时间的限制。是http 1.1中为了弥补 <code>Expires</code> 缺陷新加入的。</p>
</li>
<li>
<p>相关控制字段</p>
<p>：</p>
<ul>
<li><code>s-maxage=[秒]</code> — 类似于max-age属性，除了他应用于共享（如：代理服务器）缓存</li>
<li><code>public</code> — 标记认证内容也可以被缓存，一般来说： 经过HTTP认证才能访问的内容，输出是自动不可以缓存的；</li>
<li><code>no-cache</code> — 强制每次请求直接发送给源服务器，而不经过本地缓存版本的校验。这对于需要确认认证应用很有用（可以和public结合使用），或者严格要求使用最新数据 的应用（不惜牺牲使用缓存的所有好处）；</li>
<li><code>no-store</code> — 强制缓存在任何情况下都不要保留任何副本</li>
<li><code>must-revalidate</code> — 告诉缓存必须遵循所有你给予副本的新鲜度的</li>
<li><code>proxy-revalidate</code> — 和 <code>must-revalidate</code> 类似，除了他只对缓存代理服务器起作用</li>
</ul>
</li>
</ul>
<h5 id="Last-Modified-If-Modified-Since-协商缓存机制">Last-Modified/If-Modified-Since (协商缓存机制)</h5>
<ul>
<li>通常服务器知道你所请求的数据的最后修改时间，并且 HTTP 为服务器提供了一种将最近修改数据连同你请求的数据一同发送的方法。</li>
<li>如果你第二次 (或第三次，或第四次) 请求相同的数据，告诉服务器上一次获得的最后修改日期：在请求中发送一个 <code>If-Modified-Since</code> 头信息，它包含了上一次从服务器连同数据所获得的日期。</li>
<li>如果数据从那时起没有改变，服务器将返回一个特殊的 HTTP 状态代码 304，这意味着 “从上一次请求后这个数据没有改变”。</li>
<li>当服务器发送状态编码 304 时，不再重新发送数据。所以当数据没有更新时，你不需要一次又一次地下载相同的数据</li>
<li><strong>兼容性</strong> ：所有现代的浏览器都支持 (<code>last-modified</code>) 的数据检查。</li>
</ul>
<h5 id="ETag-If-None-Match-协商缓存机制">ETag/If-None-Match (协商缓存机制)</h5>
<ul>
<li><strong>作用</strong>： 没有变化时不重新下载数据</li>
<li>工作方式：
<ol>
<li><code>Etag</code>是上一次加载资源时，服务器返回的 <code>response header</code>，是对该资源的一种唯一标识，只要资源有变化，<code>Etag</code>就会重新生成</li>
<li>浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的 <code>Etag</code> 值放到 <code>request header</code> 里的 <code>If-None-Match</code> 里，服务器比较客户端传来的 <code>If-None-Match</code> 跟自己服务器上该资源的 <code>ETag</code> 是否一致</li>
<li>如果服务器发现 <code>ETag</code> 匹配不上，那么直接以常规 <code>GET 200</code> 回包形式将新的资源（当然也包括了新的 <code>ETag</code> ）发给客户端；如果 <code>ETag</code> 是一致的，则直接返回304知会客户端直接使用本地缓存即可。</li>
</ol>
</li>
</ul>
<h5 id="几种缓存策略的对比">几种缓存策略的对比</h5>
<h4 id="两种强缓存机制对比-Expires-VS-Cache-Control">两种强缓存机制对比 <code>Expires</code> VS <code>Cache-Control</code></h4>
<ul>
<li><strong>差别不大</strong>，区别就是 <code>Expires</code> 是 <code>HTTP1.0</code> 的产物，而 <code>Cache-Control</code> 是 <code>HTTP1.1</code> 的产物</li>
<li><strong>优先级上</strong>，两者同时存在的话，<code>Cache-Control</code> 优先级高于 <code>Expires</code> ,<code>Expires</code> 更像是一种备选方案，在某些不支持 <code>Cache-Control</code> 的环境中发挥作用</li>
<li><strong>二者共同的弊端</strong> 就是这种强缓存的机制仅仅关心缓存是否超出或者超过某个过期时间，并不关心服务器端的资源是否已经更新，所以单纯使用这两种缓存策略会导致客户端拿到的资源不是最新的</li>
</ul>
<h5 id="两种协商缓存机制对比-Last-Modified-If-Modified-Since-VS-ETag-If-None-Match">两种协商缓存机制对比 <code>Last-Modified/If-Modified-Since</code> VS <code>ETag/If-None-Match</code></h5>
<ul>
<li><strong>精度上</strong>，<code>ETag</code> 要明显优于前者，<code>Last-Modified/If-Modified-Since</code> 策略的时间单位为秒，这就意味着在秒级的请求上，做不到真正的及时更新，但是 <code>ETag</code> 每次请求都会对其进行改变从而确保精度，并且在使用负载均衡的服务器上，各个服务器生成的 <code>Last-Modified</code> 也有可能不相同</li>
<li><strong>性能上</strong>，<code>ETag</code> 要逊于 <code>Last-Modified/If-Modified-Since</code> 策略，毕竟 <code>Last-Modified/If-Modified-Since</code> 策略只是记录时间，而 <code>ETag</code> 需要进行一步hash运算</li>
<li><strong>优先级上</strong>，服务器会优先考虑 <code>ETag</code></li>
</ul>
<h5 id="用户行为对缓存策略的影响">用户行为对缓存策略的影响</h5>
<blockquote>
<p>并不是所有的操作都会启用正常的缓存机制，在某些用户行为下，缓存机制是可以正常跳过的</p>
</blockquote>
<ol>
<li>地址栏访问，链接跳转是正常用户行为，将会触发浏览器缓存机制</li>
<li>F5刷新，浏览器会设置<code>max-age=0</code>，跳过强缓存判断，会进行协商缓存判断</li>
<li>ctrl+F5刷新，跳过强缓存和协商缓存，直接从服务器拉取资源</li>
</ol>
<h4 id="浏览器渲染原理">浏览器渲染原理</h4>
<p><strong>渲染主流程</strong></p>
<p>渲染引擎首先通过网络获得所请求文档的内容，通常以8K分块的方式完成。下面是渲染引擎在取得内容之后的基本流程：</p>
<p>解析html以构建dom树 -&gt; 构建render树 -&gt; 布局render树 -&gt; 绘制render树</p>
<p><img src="https://pic002.cnblogs.com/images/2011/265173/2011110316263715.png" alt="img"></p>
<p>这里先解释一下几个概念，方便大家理解：</p>
<p>DOM Tree：浏览器将HTML解析成树形的数据结构。</p>
<p>CSS Rule Tree：浏览器将CSS解析成树形的数据结构。</p>
<p>Render Tree: DOM和CSSOM合并后生成Render Tree。</p>
<p>layout: 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置。</p>
<p>painting: 按照算出来的规则，通过显卡，把内容画到屏幕上。</p>
<p>reflow（回流）：当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，内行称这个回退的过程叫 reflow。reflow 会从 <html> 这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置。reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。</p>
<p>repaint（重绘）：改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。</p>
<p><em>注意：(1)display:none 的节点不会被加入Render Tree，而visibility: hidden 则会，所以，如果某个节点最开始是不显示的，设为display:none是更优的。</em></p>
<p><em>(2)display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发现位置变化。</em></p>
<p><em>(3)有些情况下，比如修改了元素的样式，浏览器并不会立刻reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow。但是在有些情况下，比如resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。</em></p>
<p><strong>构建DOM树</strong></p>
<p>当浏览器接收到服务器响应来的HTML文档后，会遍历文档节点，生成DOM树。<br>
需要注意以下几点：</p>
<ul>
<li>DOM树在构建的过程中可能会被CSS和JS的加载而执行阻塞</li>
<li><code>display:none</code>的元素也会在DOM树中</li>
<li>注释也会在DOM树中</li>
<li><code>script</code>标签会在DOM树中</li>
</ul>
<p>无论是DOM还是CSSOM，都是要经过<code>Bytes→characters→tokens→nodes→object model</code>这个过程。当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。</p>
<p><strong>构建CSSOM规则树</strong></p>
<p>浏览器解析CSS文件并生成CSSOM，每个CSS文件都被分析成一个StyleSheet对象，每个对象都包含CSS规则。CSS规则对象包含对应于CSS语法的选择器和声明对象以及其他对象。<br>
在这个过程需要注意的是：</p>
<ul>
<li>CSS解析可以与DOM解析同时进行。</li>
<li>CSS解析与<code>script</code>的执行互斥 。</li>
<li>在Webkit内核中进行了<code>script</code>执行优化，只有在JS访问CSS时才会发生互斥。</li>
</ul>
<p><strong>构建渲染树（Render Tree）</strong></p>
<p>通过DOM树和CSS规则树，浏览器就可以通过它两构建渲染树了。浏览器会先从DOM树的根节点开始遍历每个可见节点，然后对每个可见节点找到适配的CSS样式规则并应用。<br>
有以下几点需要注意：</p>
<ul>
<li>Render Tree和DOM Tree不完全对应</li>
<li><code>display: none</code>的元素不在Render Tree中</li>
<li><code>visibility: hidden</code>的元素在Render Tree中</li>
</ul>
<p>渲染树生成后，还是没有办法渲染到屏幕上，渲染到屏幕需要得到各个节点的位置信息，这就需要布局（Layout）的处理了。</p>
<p><strong>渲染树布局(layout of the render tree)</strong></p>
<p>布局阶段会从渲染树的根节点开始遍历，由于渲染树的每个节点都是一个Render Object对象，包含宽高，位置，背景色等样式信息。所以浏览器就可以通过这些样式信息来确定每个节点对象在页面上的确切大小和位置，布局阶段的输出就是我们常说的盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。需要注意的是：</p>
<ul>
<li><code>float</code>元素，<code>absoulte</code>元素，<code>fixed</code>元素会发生位置偏移。</li>
<li>我们常说的脱离文档流，其实就是脱离Render Tree。</li>
</ul>
<p><strong>渲染树绘制（Painting the render tree）</strong></p>
<p>在绘制阶段，浏览器会遍历渲染树，调用渲染器的<code>paint()</code>方法在屏幕上显示其内容。渲染树的绘制工作是由浏览器的UI后端组件完成的。</p>
<h4 id="浏览器渲染网页的那些事儿">浏览器渲染网页的那些事儿</h4>
<h4 id="浏览器主要组件结构">浏览器主要组件结构</h4>
<p><img src="https:////upload-images.jianshu.io/upload_images/3534846-379346e21d0d5c84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400/format/webp" alt="img"></p>
<p>浏览器主要组件</p>
<p>渲染引擎主要有两个：webkit和Gecko<br>
Firefox使用Geoko，Mozilla自主研发的渲染引擎。Safari和Chrome都使用webkit。Webkit是一款开源渲染引擎，它本来是为linux平台研发的，后来由Apple移植到Mac及Windows上。<br>
虽然主流浏览器渲染过程叫法有区别，但是主要流程还是相同的。</p>
<h4 id="渲染阻塞">渲染阻塞</h4>
<p>JS可以操作DOM来修改DOM结构，可以操作CSSOM来修改节点样式，这就导致了浏览器在遇到<code>&lt;script&gt;</code>标签时，DOM构建将暂停，直至脚本完成执行，然后继续构建DOM。如果脚本是外部的，会等待脚本下载完毕，再继续解析文档。现在可以在<code>script</code>标签上增加属性<code>defer</code>或者<code>async</code>。脚本解析会将脚本中改变DOM和CSS的地方分别解析出来，追加到DOM树和CSSOM规则树上。</p>
<p>每次去执行JavaScript脚本都会严重地阻塞DOM树的构建，如果JavaScript脚本还操作了CSSOM，而正好这个CSSOM还没有下载和构建，浏览器甚至会延迟脚本执行和构建DOM，直至完成其CSSOM的下载和构建。所以，<code>script</code>标签的位置很重要。</p>
<p>JS阻塞了构建DOM树，也阻塞了其后的构建CSSOM规则树，整个解析进程必须等待JS的执行完成才能够继续，这就是所谓的JS阻塞页面。</p>
<p>由于CSSOM负责存储渲染信息，浏览器就必须保证在合成渲染树之前，CSSOM是完备的，这种完备是指所有的CSS（内联、内部和外部）都已经下载完，并解析完，只有CSSOM和DOM的解析完全结束，浏览器才会进入下一步的渲染，这就是CSS阻塞渲染。</p>
<p>CSS阻塞渲染意味着，在CSSOM完备前，页面将一直处理白屏状态，这就是为什么样式放在<code>head</code>中，仅仅是为了更快的解析CSS，保证更快的首次渲染。</p>
<p>需要注意的是，即便你没有给页面任何的样式声明，CSSOM依然会生成，默认生成的CSSOM自带浏览器默认样式。</p>
<p>当解析HTML的时候，会把新来的元素插入DOM树里面，同时去查找CSS，然后把对应的样式规则应用到元素上，查找样式表是按照从右到左的顺序去匹配的。</p>
<p>例如：<code>div p &#123;font-size: 16px&#125;</code>，会先寻找所有<code>p</code>标签并判断它的父标签是否为<code>div</code>之后才会决定要不要采用这个样式进行渲染）。<br>
所以，我们平时写CSS时，尽量用<code>id</code>和<code>class</code>，千万不要过渡层叠。</p>
<h4 id="回流和重绘（reflow和repaint）">回流和重绘（reflow和repaint）</h4>
<p>我们都知道HTML默认是流式布局的，但CSS和JS会打破这种布局，改变DOM的外观样式以及大小和位置。因此我们就需要知道两个概念：<code>replaint</code>和<code>reflow</code>。</p>
<h5 id="reflow（回流）">reflow（回流）</h5>
<p>当浏览器发现布局发生了变化，这个时候就需要倒回去重新渲染，这个回退的过程叫<code>reflow</code>。<code>reflow</code>会从<code>html</code>这个<code>root frame</code>开始递归往下，依次计算所有的结点几何尺寸和位置，以确认是渲染树的一部分发生变化还是整个渲染树。<code>reflow</code>几乎是无法避免的，因为只要用户进行交互操作，就势必会发生页面的一部分的重新渲染，且通常我们也无法预估浏览器到底会<code>reflow</code>哪一部分的代码，因为他们会相互影响。</p>
<h5 id="repaint（重绘）">repaint（重绘）</h5>
<p><code>repaint</code>则是当我们改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸和位置没有发生改变。</p>
<p>需要注意的是，<code>display:none</code>会触发<code>reflow</code>，而<code>visibility: hidden</code>属性则并不算是不可见属性，它的语义是隐藏元素，但元素仍然占据着布局空间，它会被渲染成一个空框。所以<code>visibility:hidden</code>只会触发<code>repaint</code>，因为没有发生位置变化。</p>
<p>另外有些情况下，比如修改了元素的样式，浏览器并不会立刻<code>reflow</code>或<code>repaint</code>一次，而是会把这样的操作积攒一批，然后做一次<code>reflow</code>，这又叫异步<code>reflow</code>或增量异步<code>reflow</code>。但是在有些情况下，比如<code>resize</code>窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行<code>reflow</code>。</p>
<h5 id="引起reflow">引起reflow</h5>
<p>现代浏览器会对回流做优化，它会等到足够数量的变化发生，再做一次批处理回流。</p>
<ul>
<li>页面第一次渲染（初始化）</li>
<li>DOM树变化（如：增删节点）</li>
<li>Render树变化（如：<code>padding</code>改变）</li>
<li>浏览器窗口<code>resize</code></li>
<li>获取元素的某些属性</li>
</ul>
<p>浏览器为了获得正确的值也会提前触发回流，这样就使得浏览器的优化失效了，这些属性包括<code>offsetLeft、offsetTop、offsetWidth、offsetHeight、 scrollTop/Left/Width/Height、clientTop/Left/Width/Height</code>、调用了<code>getComputedStyle()</code>。</p>
<h5 id="引起repaint">引起repaint</h5>
<p><code>reflow</code>回流必定引起<code>repaint</code>重绘，重绘可以单独触发。<br>
背景色、颜色、字体改变（注意：字体大小发生变化时，会触发回流）</p>
<h5 id="减少reflow、repaint触发次数">减少reflow、repaint触发次数</h5>
<ul>
<li>用<code>transform</code>做形变和位移可以减少<code>reflow</code></li>
<li>避免逐个修改节点样式，尽量一次性修改</li>
<li>使用<code>DocumentFragment</code>将需要多次修改的DOM元素缓存，最后一次性<code>append</code>到真实DOM中渲染</li>
<li>可以将需要多次修改的DOM元素设置<code>display:none</code>，操作完再显示。（因为隐藏元素不在<code>render</code>树内，因此修改隐藏元素不会触发回流重绘）</li>
<li>避免多次读取某些属性</li>
<li>通过绝对位移将复杂的节点元素脱离文档流，形成新的Render Layer，降低回流成本</li>
</ul>
<h4 id="几条关于优化渲染效率的建议">几条关于优化渲染效率的建议</h4>
<p>结合上文有以下几点可以优化渲染效率。</p>
<ul>
<li>合法地去书写HTML和CSS ，且不要忘了文档编码类型。</li>
<li>样式文件应当在<code>head</code>标签中，而脚本文件在<code>body</code>结束前，这样可以防止阻塞的方式。</li>
<li>简化并优化CSS选择器，尽量将嵌套层减少到最小。</li>
<li>DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。</li>
<li>如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。</li>
<li>不要一条条地改变样式，而要通过改变<code>class</code>，或者<code>csstext</code>属性，一次性地改变样式。</li>
<li>尽量用<code>transform</code>来做形变和位移</li>
<li>尽量使用离线DOM，而不是真实的网页DOM，来改变元素样式。比如，操作<code>Document Fragment</code>对象，完成后再把这个对象加入DOM。再比如，使用<code>cloneNode()</code>方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。</li>
<li>先将元素设为<code>display: none</code>（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。</li>
<li><code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。</li>
<li>只在必要的时候，才将元素的<code>display</code>属性为可见，因为不可见的元素不影响重排和重绘。另外，<code>visibility : hidden</code>的元素只对重绘有影响，不影响重排。</li>
<li>使用<code>window.requestAnimationFrame()</code>、<code>window.requestIdleCallback()</code>这两个方法调节重新渲染。</li>
</ul>
<p>来看看webkit的主要流程：*<br>
*</p>
<p><img src="https://images2018.cnblogs.com/blog/1028513/201805/1028513-20180530154313816-1498972038.png" alt="img"></p>
<p>再来看看Geoko的主要流程：</p>
<p><img src="https://images2018.cnblogs.com/blog/1028513/201805/1028513-20180530154341813-2090367224.jpg" alt="img"></p>
<p>Gecko 里把格式化好的可视元素称做“帧树”（Frame tree）。每个元素就是一个帧（frame）。 webkit 则使用”渲染树”这个术语，渲染树由”渲染对象”组成。webkit 里使用”layout”表示元素的布局，Gecko则称为”reflow”。Webkit使用”Attachment”来连接DOM节点与可视化信息以构建渲染树。一个非语义上的小差别是Gecko在HTML与DOM树之间有一个附加的层 ，称作”content sink”，是创建DOM对象的工厂。</p>
<p>尽管Webkit与Gecko使用略微不同的术语，这个过程还是基本相同的，如下：</p>
<p>1. 浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。</p>
<p>2. 将CSS解析成 CSS Rule Tree 。</p>
<p>3. 根据DOM树和CSSOM来构造 Rendering Tree。注意：Rendering Tree 渲染树并不等同于 DOM 树，因为一些像Header或display:none的东西就没必要放在渲染树中了。</p>
<p>4. 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作称之为layout，顾名思义就是计算出每个节点在屏幕中的位置。</p>
<p>5. 再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。</p>
<p>注意：<em>上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容</em>。</p>
<h4 id="强缓存与协商缓存">强缓存与协商缓存</h4>
<p>在工作中，前端代码打包之后的生成的静态资源就要发布到静态服务器上，这时候就要做对这些静态资源做一些运维配置，其中，gzip和设置缓存是必不可少的。这两项是最直接影响到网站性能和用户体验的。</p>
<p>缓存的优点：</p>
<ul>
<li>减少了不必要的数据传输，节省带宽</li>
<li>减少服务器的负担，提升网站性能</li>
<li>加快了客户端加载网页的速度</li>
<li>用户体验友好</li>
</ul>
<p>缺点：</p>
<ul>
<li>资源如果有更改但是客户端不及时更新会造成用户获取信息滞后，如果老版本有bug的话，情况会更加糟糕。</li>
</ul>
<p><strong>所以，为了避免设置缓存错误，掌握缓存的原理对于我们工作中去更加合理的配置缓存是非常重要的。</strong></p>
<h5 id="一、强缓存">一、强缓存</h5>
<p>到底什么是强缓存？强在哪？其实强是强制的意思。当浏览器去请求某个文件的时候，服务端就在respone header里面对该文件做了缓存配置。缓存的时间、缓存类型都由服务端控制，具体表现为：<br>
respone header 的cache-control，常见的设置是max-age public private no-cache no-store等</p>
<p>如下图,<br>
设置了<strong>cache-control:max-age=31536000,public,immutable</strong></p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6782944-2953183b0a2ab1dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/751/format/webp" alt="img"></p>
<p>image.png</p>
<p>max-age表示缓存的时间是31536000秒（1年），public表示可以被浏览器和代理服务器缓存，代理服务器一般可用nginx来做。immutable表示该资源永远不变，但是实际上该资源并不是永远不变，它这么设置的意思是为了让用户在刷新页面的时候不要去请求服务器！啥意思？就是说，如果你只设置了cahe-control:max-age=31536000,public  这属于强缓存，每次用户正常打开这个页面，浏览器会判断缓存是否过期，没有过期就从缓存中读取数据；但是有一些 “聪明” 的用户会点击浏览器左上角的刷新按钮去刷新页面，这时候就算资源没有过期（1年没这么快过），浏览器也会直接去请求服务器，这就是额外的请求消耗了，这时候就相当于是走协商缓存的流程了（下面会讲到）。如果cahe-control:max-age=315360000,public再加个immutable的话，就算用户刷新页面，浏览器也不会发起请求去服务，浏览器会直接从本地磁盘或者内存中读取缓存并返回200状态，看上图的红色框（from memory cache）。这是2015年facebook团队向制定 HTTP 标准的 IETF 工作组提到的建议：他们希望 HTTP 协议能给 Cache-Control 响应头增加一个属性字段表明该资源永不过期，浏览器就没必要再为这些资源发送条件请求了。</p>
<h5 id="强缓存总结">强缓存总结</h5>
<ol>
<li>cache-control: max-age=xxxx，public<br>
客户端和代理服务器都可以缓存该资源；<br>
客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 ，如果用户做了刷新操作，就向服务器发起http请求</li>
<li>cache-control: max-age=xxxx，private<br>
只让客户端可以缓存该资源；代理服务器不缓存<br>
客户端在xxx秒内直接读取缓存,statu code:200</li>
<li>cache-control: max-age=xxxx，immutable<br>
客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 ，即使用户做了刷新操作，也不向服务器发起http请求</li>
<li>cache-control: no-cache<br>
跳过设置强缓存，但是不妨碍设置协商缓存；一般如果你做了强缓存，只有在强缓存失效了才走协商缓存的，设置了no-cache就不会走强缓存了，每次请求都回询问服务端。</li>
<li>cache-control: no-store<br>
不缓存，这个会让客户端、服务器都不缓存，也就没有所谓的强缓存、协商缓存了。</li>
</ol>
<h5 id="二、协商缓存">二、协商缓存</h5>
<p>上面说到的强缓存就是给资源设置个过期时间，客户端每次请求资源时都会看是否过期；只有在过期才会去询问服务器。所以，强缓存就是为了给客户端自给自足用的。而当某天，客户端请求该资源时发现其过期了，这是就会去请求服务器了，而这时候去请求服务器的这过程就可以设置协商缓存。这时候，协商缓存就是需要客户端和服务器两端进行交互的。</p>
<p><strong>怎么设置协商缓存？</strong></p>
<p>response header里面的设置</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">etag: <span class="token string">'5c20abbd-e2e8'</span>
last-modified: Mon, <span class="token number">24</span> Dec <span class="token number">2018</span> 09:49:49 GMT</code></pre>
<p>etag：每个文件有一个，改动文件了就变了，就是个文件hash，每个文件唯一，就像用webpack打包的时候，每个资源都会有这个东西，如： app.js打包后变为 app.c20abbde.js，加个唯一hash，也是为了解决缓存问题。</p>
<p>last-modified：文件的修改时间，精确到秒</p>
<p>也就是说，每次请求返回来 response header 中的 etag和 last-modified，在下次请求时在 request header 就把这两个带上，服务端把你带过来的标识进行对比，然后判断资源是否更改了，如果更改就直接返回新的资源，和更新对应的response header的标识etag、last-modified。如果资源没有变，那就不变etag、last-modified，这时候对客户端来说，每次请求都是要进行协商缓存了，即：</p>
<p>发请求–&gt;看资源是否过期–&gt;过期–&gt;请求服务器–&gt;服务器对比资源是否真的过期–&gt;没过期–&gt;返回304状态码–&gt;客户端用缓存的老资源。</p>
<p>这就是一条完整的协商缓存的过程。</p>
<p>当然，当服务端发现资源真的过期的时候，会走如下流程：</p>
<p>发请求–&gt;看资源是否过期–&gt;过期–&gt;请求服务器–&gt;服务器对比资源是否真的过期–&gt;过期–&gt;返回200状态码–&gt;客户端如第一次接收该资源一样，记下它的cache-control中的max-age、etag、last-modified等。</p>
<p>所以协商缓存步骤总结：</p>
<p>请求资源时，把用户本地该资源的 etag 同时带到服务端，服务端和最新资源做对比。<br>
如果资源没更改，返回304，浏览器读取本地缓存。<br>
如果资源有更改，返回200，返回最新的资源。</p>
<p>补充一点，response header中的etag、last-modified在客户端重新向服务端发起请求时，会在request header中换个key名：</p>
<pre class="language-csharp" data-language="csharp"><code class="language-csharp"><span class="token comment">// response header</span>
etag<span class="token punctuation">:</span> '5c20abbd<span class="token operator">-</span>e2e8'
last<span class="token operator">-</span>modified<span class="token punctuation">:</span> Mon<span class="token punctuation">,</span> <span class="token number">24</span> Dec <span class="token number">2018</span> <span class="token number">09</span><span class="token punctuation">:</span><span class="token number">49</span><span class="token punctuation">:</span><span class="token number">49</span> GMT

<span class="token comment">// request header 变为</span>
<span class="token keyword">if</span><span class="token operator">-</span>none<span class="token operator">-</span>matched<span class="token punctuation">:</span> '5c20abbd<span class="token operator">-</span>e2e8'
<span class="token keyword">if</span><span class="token operator">-</span>modified<span class="token operator">-</span>since<span class="token punctuation">:</span> Mon<span class="token punctuation">,</span> <span class="token number">24</span> Dec <span class="token number">2018</span> <span class="token number">09</span><span class="token punctuation">:</span><span class="token number">49</span><span class="token punctuation">:</span><span class="token number">49</span> GMT</code></pre>
<p><strong>为什么要有etag？</strong><br>
你可能会觉得使用last-modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要etag呢？HTTP1.1中etag的出现（也就是说，etag是新增的，为了解决之前只有If-Modified的缺点）主要是为了解决几个last-modified比较难解决的问题：</p>
<ol>
<li>
<p>一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新get；</p>
</li>
<li>
<p>某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，if-modified-since能检查到的粒度是秒级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；</p>
</li>
<li>
<p>某些服务器不能精确的得到文件的最后修改时间。</p>
</li>
</ol>
<h5 id="怎么设置强缓存与协商缓存">怎么设置强缓存与协商缓存</h5>
<ol>
<li>
<p>后端服务器如nodejs:<br>
res.setHeader(‘max-age’: ‘3600 public’)<br>
res.setHeader(etag: ‘5c20abbd-e2e8’)<br>
res.setHeader(‘last-modified’: Mon, 24 Dec 2018 09:49:49 GMT)</p>
</li>
<li>
<p>nginx配置</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6782944-b8701adefe6341e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/583/format/webp" alt="img"></p>
<p>image.png</p>
</li>
</ol>
<p>偶尔自己折腾一番非前端的东西时，若心中有数，自然不会手忙脚乱。</p>
<h5 id="怎么去用？">怎么去用？</h5>
<p>举个例子，像目前用vue-cli打包后生成的单页文件是有一个html，与及一堆js css img资源，怎么去设置这些文件呢，核心需求是</p>
<ol>
<li>
<p>要有缓存，毋庸置疑</p>
</li>
<li>
<p>当发新包的时候，要避免加载老的缓存资源</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/6782944-618911ae2fbba06c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/236/format/webp" alt="img"></p>
<p>打包好的静态文件</p>
</li>
</ol>
<p><strong>我的做法是：</strong><br>
index.html文件采用协商缓存，理由就是要用户每次请求index.html不拿浏览器缓存，直接请求服务器，这样就保证资源更新了，用户能马上访问到新资源，如果服务端返回304，这时候再拿浏览器的缓存的index.html，<strong>切记不要设置强缓存！！！</strong></p>
<p>其他资源采用强缓存 + 协商缓存,理由就不多说了。</p>
<h3 id="算法">算法</h3>
<h4 id="数组扁平化">数组扁平化</h4>
<pre class="language-js" data-language="js"><code class="language-js">
<span class="token comment">/**
 * 一、普通的递归实现
 * 在遍历过程中发现数组元素还是数组的时候进行递归操作，把数组的结果通过数组的 concat 方法拼接到最后要返回的 result 数组上
 */</span>
<span class="token comment">// function flatten(arr) &#123;</span>
<span class="token comment">//   let result = []</span>
<span class="token comment">//   for (let i = 0; i &lt; arr.length; ++i) &#123;</span>
<span class="token comment">//     if (Array.isArray(arr[i])) &#123;</span>
<span class="token comment">//       result = result.concat(flatten(arr[i]))</span>
<span class="token comment">//     &#125; else &#123;</span>
<span class="token comment">//       result.push(arr[i])</span>
<span class="token comment">//     &#125;</span>
<span class="token comment">//   &#125;</span>
<span class="token comment">//   return result</span>
<span class="token comment">// &#125;</span>

<span class="token comment">/**
 * 二、reduce迭代
 */</span>
<span class="token comment">// function flatten(arr) &#123;</span>
<span class="token comment">//   return arr.reduce((prev, next) => &#123;</span>
<span class="token comment">//     return prev.concat(Array.isArray(next) ? flatten(next) : next)</span>
<span class="token comment">//   &#125;, [])</span>
<span class="token comment">// &#125;</span>

<span class="token comment">/**
 * 三、扩展运算符实现
 * 扩展运算符和 some 的方法，两者共同使用
 * some来判断是否有数组,有就用拓展运算符展开.没有就结束
 */</span>
<span class="token comment">// function flatten(arr) &#123;</span>
<span class="token comment">//   while (arr.some(item =>  Array.isArray(item)))&#123;</span>
<span class="token comment">//     arr = [].concat(...arr)</span>
<span class="token comment">//   &#125;</span>
<span class="token comment">//   return arr</span>
<span class="token comment">// &#125;</span>

<span class="token comment">/**
 * 四、split 和 toString 共同处理
 * 数组会默认带一个 toString 的方法，
 * 把数组直接转换成逗号分隔的字符串，然后再用 split 方法把字符串重新转换为数组
 */</span>
<span class="token comment">// function flatten(arr) &#123;</span>
<span class="token comment">//   return arr.toString().split(',')</span>
<span class="token comment">// &#125;</span>

<span class="token comment">/**
 * 五、ES6 中的 flat
 * arr.flat([depth]),可以传进 Infinity
 */</span>
<span class="token comment">// function flatten(arr) &#123;</span>
<span class="token comment">//   return arr.flat(Infinity)</span>
<span class="token comment">// &#125;</span>

<span class="token comment">/**
 * 六、正则和 JSON 方法共同处理
 * 将 JSON.stringify 的方法先转换为字符串
 * 然后通过正则表达式过滤掉字符串中的数组的方括号
 * 最后再利用 JSON.parse 把它转换成数组
 */</span>
<span class="token keyword">function</span> <span class="token function">flatten</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">let</span> tempString <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>
  tempString <span class="token operator">=</span> tempString<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\[|\]</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">[</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>tempString<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">]</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>


<span class="token keyword">let</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">flatten</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h4 id="数组去重的方法">数组去重的方法</h4>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">es5用法
<span class="token keyword">function</span> <span class="token function">unique</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">===</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         <span class="token comment">//第一个等同于第二个，splice方法删除第二个</span>
                    arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    j<span class="token operator">--</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
<span class="token keyword">return</span> arr<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'true'</span><span class="token punctuation">,</span><span class="token string">'true'</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span><span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">NaN</span><span class="token punctuation">,</span> <span class="token number">NaN</span><span class="token punctuation">,</span><span class="token string">'NaN'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">unique</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">//[1, "true", 15, false, undefined, NaN, NaN, "NaN", "a", &#123;…&#125;, &#123;…&#125;]     //NaN和&#123;&#125;没有去重，两个null直接消失了</span>
es6的用法
<span class="token comment">// let arr = [12, 43, 23, 12, 43, 55]</span>
<span class="token comment">// let item = [...new Set(arr)]</span>
<span class="token comment">// console.log(item)</span></code></pre>
<h4 id="千位分隔符">千位分隔符</h4>
<pre class="language-none"><code class="language-none">&lt;!DOCTYPE html&gt;
&lt;html lang&#x3D;&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;
    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;
    &lt;title&gt;Document&lt;&#x2F;title&gt;
&lt;&#x2F;head&gt;
&lt;body&gt;
    &lt;script&gt;
        var num &#x3D; 3899000001,
        arr &#x3D; [];
        num &#x3D; String(num);
        for(var i&#x3D;num.length-1,j&#x3D;1;i&gt;&#x3D;0;i--,j++)&#123;
            arr.push(num[i]);
            if(j%3&#x3D;&#x3D;0 &amp;&amp; i !&#x3D; 0)&#123;
                arr.push(&#39;,&#39;)
            &#125;
        &#125;
        console.log(arr.reverse().join(&#39;&#39;))
    &lt;&#x2F;script&gt;
&lt;&#x2F;body&gt;
&lt;&#x2F;html&gt;</code></pre>
<h4 id="js实现Map结构">js实现Map结构</h4>
<pre class="language-none"><code class="language-none">function myMap()&#123;
	var length &#x3D; 0;
	var obj &#x3D; new Object();

	&#x2F;*判断对象中是否包含给定的key*&#x2F;
	this.containsKey&#x3D;function(key)&#123;
		return (key in obj)
		&#125;

	&#x2F;*向map中添加数据*&#x2F;
	this.put &#x3D; function(key,value)&#123;
		if(!this.containsKey(key))&#123;
			length++;
		&#125;
		obj[key] &#x3D; value;
	&#125;

	&#x2F;*根据key值获取value*&#x2F;
	this.get &#x3D; function(key)&#123;
		return this.containsKey(key) ? obj[key] : null;
	&#125;

	&#x2F;*判断map中是否包含给定的value*&#x2F;
	this.containsValue &#x3D; function(value)&#123;
		for(var key in obj)&#123;
			if(obj[key] &#x3D;&#x3D; value)&#123;
				return true;
			&#125;
		&#125;
		return false;
	&#125;

	&#x2F;*获取Map中所有key*&#x2F;
	this.keySet &#x3D; function()&#123;
		var _keys &#x3D; new Array();
		for(var key in obj)&#123;
			_keys.push(key);
		&#125;
		return _keys;
	&#125;

	&#x2F;*获取Map的长度*&#x2F;
	this.size &#x3D; function()&#123;
		return length;
	&#125;

	&#x2F;*清空Map*&#x2F;
	this.clear &#x3D; function()&#123;
		length &#x3D; 0;
		obj &#x3D; new Object();
	&#125;
&#125;</code></pre>
<h4 id="手写LRU">手写LRU</h4>
<pre class="language-none"><code class="language-none">&#x2F;&#x2F; 请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。
实现 LRUCache 类：
LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存
int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。
函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。

var LRUCache &#x3D; function(capacity) &#123;
    this.capacity &#x3D; capacity
    this.cache &#x3D; new Map();
&#125;;

LRUCache.prototype.get &#x3D; function(key) &#123;
    if(this.cache.has(key)) &#123;
        let value &#x3D; this.cache.get(key)
        this.cache.delete(key, value)
        this.cache.set(key, value)
        return value
    &#125;
    return -1;
&#125;;

LRUCache.prototype.put &#x3D; function(key, value) &#123;
    if(this.cache.has(key)) &#123;
        let temp &#x3D; this.cache.get(key)
        this.cache.delete(key, temp)
    &#125;else if(this.cache.size&gt;&#x3D;this.capacity) &#123;
        this.cache.delete(this.cache.keys().next().value)
    &#125;
    this.cache.set(key,value)
&#125;;</code></pre>
<h4 id="快排-js中最快">快排(js中最快)</h4>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">121</span><span class="token punctuation">,</span><span class="token number">34</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">67</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">65</span><span class="token punctuation">,</span><span class="token number">90</span><span class="token punctuation">]</span>
<span class="token keyword">var</span> <span class="token function-variable function">quickSort</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
    <span class="token keyword">let</span> pivotIndex <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token keyword">let</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>pivotIndex<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    <span class="token keyword">let</span> left <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">let</span> right <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">,</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>pivot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            left<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            right<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">[</span>pivot<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<h4 id="堆排序">堆排序</h4>
<pre class="language-none"><code class="language-none"></code></pre>
<h4 id="归并排序">归并排序</h4>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">let</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length
    <span class="token keyword">if</span><span class="token punctuation">(</span>len<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> arr
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">let</span> middle <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>len<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token keyword">let</span> left <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>middle<span class="token punctuation">)</span>
    <span class="token keyword">let</span> right <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>middle<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token function">mergeSort</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">function</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span>right</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>length<span class="token operator">></span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>right<span class="token punctuation">.</span>length<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span>right<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>right<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>right<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>right<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> result
<span class="token punctuation">&#125;</span></code></pre>
<h4 id="切金条">切金条</h4>
<p><img src="https://xin--images.oss-cn-hongkong.aliyuncs.com/images1/202202281932477.png" alt="image-20220228193228971"></p>
<h4 id="红黑树">红黑树</h4>
<p>自平衡的二叉搜索树</p>
<p>1.结点是红色或者是黑色（结点上有一个color属性）</p>
<p>2.根结点是黑色</p>
<p>3.叶子结点都是黑色，且为null（NIL结点）</p>
<p>4.连接红色结点的两个子结点都是黑色，红色结点的父节点都是黑色，红色节点的子节点都是黑色</p>
<p>5.从任意结点出发，到其每个叶子结点的路径包含相同数据的黑色节点</p>
<p>这5条就是红黑树给出的自动维持平衡所具备的规则</p>
<p>插入结点是红色的，根据规则再改颜色</p>
<p>是为了保证：从根节点到叶子节点的最长路径不大于最短路径的2倍</p>
<p>红黑树插入数据的时候。会先去遍历数据应该插入那个位置，插入的数据一定为红色</p>
<h4 id="链表判断是否有环">链表判断是否有环</h4>
</script></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:xiaoxinvvzzz@sina.com">Xiaoxin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://beihai-yu.github.io/2022/03/01/shi-xi/">http://beihai-yu.github.io/2022/03/01/shi-xi/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://BeiHai-yu.github.io" target="_blank">Xiaoxin's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-61076b7f05407964" async="async"></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://xin--images.oss-cn-hongkong.aliyuncs.com/images/20210803214143.jpg" target="_blank"><img class="post-qr-code-img" src="https://xin--images.oss-cn-hongkong.aliyuncs.com/images/20210803214143.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://xin--images.oss-cn-hongkong.aliyuncs.com/images/20210803214144.jpg" target="_blank"><img class="post-qr-code-img" src="https://xin--images.oss-cn-hongkong.aliyuncs.com/images/20210803214144.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2021/10/27/github-fen-zhi-he-bing-wen-ti/"><img class="next-cover" src="https://xin--images.oss-cn-hongkong.aliyuncs.com/images1/202110272031511.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">github分支合并问题</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.</span> <span class="toc-text">项目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98"><span class="toc-number">1.0.1.</span> <span class="toc-text">权限问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%AF%B9%E6%AF%94"><span class="toc-number">2.1.</span> <span class="toc-text">一些对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%BF%E7%94%A8Jquery%E5%92%8C%E4%BD%BF%E7%94%A8vue%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.1.</span> <span class="toc-text">说一下使用Jquery和使用vue的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML"><span class="toc-number">2.2.</span> <span class="toc-text">HTML</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#link%E5%92%8C-impor%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.1.</span> <span class="toc-text">link和@impor区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.2.2.</span> <span class="toc-text">图片懒加载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#css"><span class="toc-number">2.3.</span> <span class="toc-text">css</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-number">2.3.1.</span> <span class="toc-text">水平垂直居中</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.3.1.1.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80"><span class="toc-number">2.3.2.</span> <span class="toc-text">三栏布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PNG"><span class="toc-number">2.3.3.</span> <span class="toc-text">PNG</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#font-12px-2"><span class="toc-number">2.3.4.</span> <span class="toc-text">font:12px&#x2F;2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS%E9%80%89%E6%8B%A9%E5%99%A8%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">2.3.5.</span> <span class="toc-text">CSS选择器优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C%E7%BA%A7%E5%88%AB%EF%BC%9A"><span class="toc-number">2.3.5.0.1.</span> <span class="toc-text">相同级别：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.3.6.</span> <span class="toc-text">盒子模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BFC%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">2.3.7.</span> <span class="toc-text">BFC块级格式化上下文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E6%98%AF%E5%90%A6%E5%9C%A8iframe%E4%B8%AD"><span class="toc-number">2.3.8.</span> <span class="toc-text">如何判断当前是否在iframe中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E6%80%BB%E7%BB%93"><span class="toc-number">2.3.9.</span> <span class="toc-text">响应式布局总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%A1%88"><span class="toc-number">2.3.10.</span> <span class="toc-text">移动端适配的几种方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%95%E5%BC%80%E8%AF%B4%E8%AF%B4"><span class="toc-number">2.3.10.1.</span> <span class="toc-text">展开说说</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#viewport-%E9%80%82%E9%85%8D"><span class="toc-number">2.3.10.2.</span> <span class="toc-text">viewport 适配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#vw-%E9%80%82%E9%85%8D%EF%BC%88%E9%83%A8%E5%88%86%E7%AD%89%E6%AF%94%E7%BC%A9%E6%94%BE%EF%BC%89"><span class="toc-number">2.3.10.3.</span> <span class="toc-text">vw 适配（部分等比缩放）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rem-%E9%80%82%E9%85%8D"><span class="toc-number">2.3.10.4.</span> <span class="toc-text">rem 适配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%B9%E6%80%A7%E7%9B%92%E9%80%82%E9%85%8D%EF%BC%88%E5%90%88%E7%90%86%E5%B8%83%E5%B1%80%EF%BC%89"><span class="toc-number">2.3.10.5.</span> <span class="toc-text">弹性盒适配（合理布局）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.3.10.6.</span> <span class="toc-text">基于媒体查询的响应式设计</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.11.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-number">2.3.12.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%B6%B3"><span class="toc-number">2.3.13.</span> <span class="toc-text">不足</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%90%8D%E5%86%B2%E7%AA%81%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">2.3.14.</span> <span class="toc-text">类名冲突怎么解决？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-2"><span class="toc-number">2.3.15.</span> <span class="toc-text">面试题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js%E5%9F%BA%E7%A1%80"><span class="toc-number">2.4.</span> <span class="toc-text">js基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MVVM"><span class="toc-number">2.4.1.</span> <span class="toc-text">MVVM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue%E6%B2%A1%E6%9C%89%E5%AE%8C%E5%85%A8%E9%81%B5%E5%BE%AAMVVM%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.4.2.</span> <span class="toc-text">vue没有完全遵循MVVM模式的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80"><span class="toc-number">2.4.3.</span> <span class="toc-text">一些基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#style%E7%9A%84display-%E5%92%8Cvisibility%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.4.</span> <span class="toc-text">style的display 和visibility区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.4.5.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#0-1-0-2-0-3"><span class="toc-number">2.4.5.1.</span> <span class="toc-text">0.1+0.2 !&#x3D;0.3</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">2.4.6.</span> <span class="toc-text">undefined</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#js%E4%B8%ADarguments"><span class="toc-number">2.4.7.</span> <span class="toc-text">js中arguments</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.8.</span> <span class="toc-text">&#x3D;,&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84splice%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.9.</span> <span class="toc-text">数组的splice方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#splice-%E6%96%B9%E6%B3%95%E5%92%8Cslice-%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.9.1.</span> <span class="toc-text">splice()方法和slice()方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">2.4.10.</span> <span class="toc-text">数组和对象的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86-for-forEach-map-for%E2%80%A6of"><span class="toc-number">2.4.10.1.</span> <span class="toc-text">数组遍历(for,forEach,map,for…of)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E9%81%8D%E5%8E%86"><span class="toc-number">2.4.10.2.</span> <span class="toc-text">对象遍历</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for%E2%80%A6in-%E5%92%8Cfor%E2%80%A6-of"><span class="toc-number">2.4.11.</span> <span class="toc-text">for…in 和for… of</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Symbol"><span class="toc-number">2.4.12.</span> <span class="toc-text">Symbol</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-number">2.4.13.</span> <span class="toc-text">对象数组去重</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96%EF%BC%9A"><span class="toc-number">2.4.14.</span> <span class="toc-text">数组扁平化：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.4.15.</span> <span class="toc-text">深拷贝和浅拷贝，实现深拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.15.1.</span> <span class="toc-text">深拷贝实现的方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.4.15.2.</span> <span class="toc-text">实现一个深拷贝</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JSON%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.4.15.3.</span> <span class="toc-text">JSON格式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E8%BF%98%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.4.16.</span> <span class="toc-text">判断是一个数组还是一个对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#typeof%E5%92%8Cinstanceof%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.17.</span> <span class="toc-text">typeof和instanceof区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#var-const-let%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.18.</span> <span class="toc-text">var,const,let的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E9%A2%98"><span class="toc-number">2.4.18.1.</span> <span class="toc-text">经典题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF"><span class="toc-number">2.4.19.</span> <span class="toc-text">对象继承</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Object-create"><span class="toc-number">2.4.19.1.</span> <span class="toc-text">Object.create</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.4.20.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-number">2.4.21.</span> <span class="toc-text">作用域链</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96"><span class="toc-number">2.4.21.1.</span> <span class="toc-text">代码优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE-with-catch"><span class="toc-number">2.4.21.2.</span> <span class="toc-text">改变作用域链(with&#x2F;catch)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.22.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.22.1.</span> <span class="toc-text">立即执行函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise"><span class="toc-number">2.4.23.</span> <span class="toc-text">Promise</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E5%86%99Promise"><span class="toc-number">2.4.24.</span> <span class="toc-text">手写Promise</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fetch%E5%92%8Cajax%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.25.</span> <span class="toc-text">fetch和ajax的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E7%9A%84ajax"><span class="toc-number">2.4.25.1.</span> <span class="toc-text">原生的ajax</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.26.</span> <span class="toc-text">跨域问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jsonp%E5%8E%9F%E7%90%86"><span class="toc-number">2.4.27.</span> <span class="toc-text">jsonp原理</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023  <i id="heartbeat" class="fa fas fa-heartbeat"></i> Xiaoxin</div><div class="footer_custom_text">Hi, welcome to my <a href="http://BeiHai-yu.github.io/">blog✨</a>!</div></div><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></head></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/algolia.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      true && mermaid.init()
    })
  }
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'pBezCOoDSixLwTE971KPKXhm-gzGzoHsz',
      appKey: 'uUFkD2xwQHOxvjracpJP4coE',
      placeholder: '记得留下你的暱称和邮箱....可以快速收到回復',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '//i0.hdslb.com/bfs/emote/',
      emojiMaps: {"tv_doge":"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png","tv_亲亲":"a8111ad55953ef5e3be3327ef94eb4a39d535d06.png","tv_偷笑":"bb690d4107620f1c15cff29509db529a73aee261.png","tv_再见":"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png","tv_冷漠":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","tv_发怒":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","tv_发财":"34db290afd2963723c6eb3c4560667db7253a21a.png","tv_可爱":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","tv_吐血":"09dd16a7aa59b77baa1155d47484409624470c77.png","tv_呆":"fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png","tv_呕吐":"9f996894a39e282ccf5e66856af49483f81870f3.png","tv_困":"241ee304e44c0af029adceb294399391e4737ef2.png","tv_坏笑":"1f0b87f731a671079842116e0991c91c2c88645a.png","tv_大佬":"093c1e2c490161aca397afc45573c877cdead616.png","tv_大哭":"23269aeb35f99daee28dda129676f6e9ea87934f.png","tv_委屈":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","tv_害羞":"a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png","tv_尴尬":"7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png","tv_微笑":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","tv_思考":"90cf159733e558137ed20aa04d09964436f618a1.png","tv_惊吓":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png"},
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.17.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=monsterid'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://pBezCOoD.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": 'pBezCOoDSixLwTE971KPKXhm-gzGzoHsz',
        "X-LC-Key": 'uUFkD2xwQHOxvjracpJP4coE',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 10/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="6892729972" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="true" muted></div><div class="app-refresh" id="app-refresh"> <div class="app-refresh-wrap"> <label>✨ 网站已更新最新版本 👉</label> <a href="javascript:void(0)" onclick="location.reload()">点击刷新</a> </div></div><script>function showNotification(){if(GLOBAL_CONFIG.Snackbar){var t="light"===document.documentElement.getAttribute("data-theme")?GLOBAL_CONFIG.Snackbar.bgLight:GLOBAL_CONFIG.Snackbar.bgDark,e=GLOBAL_CONFIG.Snackbar.position;Snackbar.show({text:"已更新最新版本",backgroundColor:t,duration:5e5,pos:e,actionText:"点击刷新",actionTextColor:"#fff",onActionClick:function(t){location.reload()}})}else{var o=`top: 0; background: ${"light"===document.documentElement.getAttribute("data-theme")?"#49b1f5":"#1f1f1f"};`;document.getElementById("app-refresh").style.cssText=o}}"serviceWorker"in navigator&&(navigator.serviceWorker.controller&&navigator.serviceWorker.addEventListener("controllerchange",function(){showNotification()}),window.addEventListener("load",function(){navigator.serviceWorker.register("/sw.js")}));</script><script src="/js/bubblex.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="140" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/57ef2727.js","daovoice")
</script><script>var isChatBtn = false
daovoice('init', {
  app_id: '57ef2727',},{
  launcher: { 
     disableLauncherIcon: isChatBtn // 悬浮 ICON 是否显示
  },
});
daovoice('update');

if (isChatBtn) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      daovoice('show')
    });
  }
  chatBtnFn()
} else {
  if (false) {
    function chatBtnHide () {
      daovoice('update', {},{
        launcher: { 
        disableLauncherIcon: true // 悬浮 ICON 是否显示
        },
      });
    }
    function chatBtnShow () {
      daovoice('update', {},{
        launcher: { 
        disableLauncherIcon: false // 悬浮 ICON 是否显示
        },
      });
    }
  }
}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300,"hOffset":50,"vOffset":-50},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>